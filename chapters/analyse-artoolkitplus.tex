\section{ARToolKitPlus} % (fold)
\label{sec:artoolkitplus}

\subsection{Datenstrukturen} % (fold)
\label{sec:datenstrukturen}

ARToolKitPlus speichert die Informationen einer Marke in zwei einfachen Datenstrukturen. Informationen zur
 Identifizierung einer Marke werden in \textproc{MarkerInfo} gespeichert (\autoref{alg:datastructure-markerinfo}) und
 Informationen zur Erkennung einer Marke werden in \textproc{MarkerInfo2} gespeichert
 (\autoref{alg:datastructure-markerinfo2}). Da \textproc{MarkerInfo} zur Identifizierung einer Marke verwendet wird,
 werde ich diese Datenstruktur nur zur Vollständigkeit erwähnen. Das Identifikationsmerkmal $\mathit{id}$ wird in
 \autoref{alg:calc} als Rückgabewert verwendet.

\input{alg/analyse-artplus/datastructure-markerinfo}

\subsubsection{MakerInfo2} % (fold)
\label{sec:makerinfo2}

Die Variable $\mathit{area}$ speichert den Flächeninhalt einer Marke, während $\mathit{pos}[2]$ die Position des
 Zentrums der Marke enthält. $\mathit{coord\_num}$ enthält die Anzahl der gefundenen Konturpixel, die in
 $\mathit{x\_coord}$ als X-Koordinate und in $\mathit{y\_coord}$ als Y-Koordinate gespeichert sind. Die konstante Größe
 $\mathit{AR\_CHAIN\_MAX}$ des Speichers für die Koordinaten wird zur Laufzeit nicht verändert. ARToolKitPlus erlaubt
 maximal $10000$ Einträge für Koordinaten pro Marke. Die Eckpunkte einer Marke sind in $\mathit{x\_coord}$ und
 $\mathit{y\_coord}$ enthalten und werden durch einen Index in $\mathit{vertex}$ referenziert. Hierbei ist zu beachten,
 dass $\mathit{vertex}$ fünf Einträge speichert, wobei der erste und letzte Eintrag auf die gleiche Koordinate
 verweisen. Dadurch kann bei der Grafikprogrammierung mit OpenGL sehr einfach ein Rahmen um eine Marke gezeichnet
 werden.

\input{alg/analyse-artplus/datastructure-markerinfo2}

Der Zugriff auf die Variablen der Datenstruktur, sowohl lesend als auch schreibend, ist konstant.

% subsubsection makerinfo2 (end)

\subsubsection{Automatischer Schwellwert} % (fold)
\label{sec:automatischer_schwellwert}

Die automatische Schwellwertanalyse von ARToolKitPlus wird durch \autoref{alg:autothresholdreset} vor ihrer Verwendung
 auf bekannte Startwerte gesetzt. Dabei wird in Zeile \ref{alg:autothresholdreset-minLum} die globale Variable
 $\mathit{minLum}$ gesetzt und in Zeile \ref{alg:autothresholdreset-maxLum} die globale Variable $\mathit{maxLum}$
 gesetzt. Die statischen Größen $\mathit{MINLUM0}$ und $\mathit{MAXLUM0}$ geben dabei die Werte an. Die Laufzeit von
 \autoref{alg:autothresholdreset} ist konstant.

\input{alg/analyse-artplus/autothresholdreset}

% subsubsection automatischer_schwellwert (end)

\subsubsection{Bildspeicher} % (fold)
\label{sec:bildspeicher}

Die Algorithmen zur Verwaltung des Bildspeichers werden zur Vollständigkeit erwähnt. Da die folgenden Algorithmen
 einmalig vor den Verfahren der Markenerkennung ausgeführt werden, haben sie auf die Analyse keinen Einfluß.

\autoref{alg:checkimagebuffer} ist beim Initialisieren der \textit{Runtime Tracking Pipeline} für die Bereitstellung
 des Bildspeichers zuständig. In Zeile \ref{alg:checkimagebuffer-size} wird die Größe des Eingangssignals mit Hilfe der
 globalen Variablen errechnet. Danach wird in Zeile
 \ref{alg:checkimagebuffer-checksize-start}--\ref{alg:checkimagebuffer-checksize-end} die errechnete Größe mit der
 Größe der globalen Variable verglichen. Wenn die Größe nicht übereinstimmt, wird in Zeile
 \ref{alg:checkimagebuffer-checkmem-start}--\ref{alg:checkimagebuffer-checkmem-end} überprüft, ob der Speicher für ein
 Bild bereits gesetzt ist. Falls der Speicherbereich schon gesetzt ist, muss er mit \autoref{alg:artkpfree} gelöscht
 werden. In Zeile \ref{alg:checkimagebuffer-sizeglobal} wird der globalen Variable die berechnete Größe des
 Bildspeichers zugewiesen. Zuletzt wird der globalen Variable des Bildspeichers ein neuer Speicherbereich in Zeile
 \ref{alg:checkimagebuffer-newmem} zugewiesen.

\input{alg/analyse-artplus/checkimagebuffer}

\autoref{alg:checkimagebuffer} wird beim ersten Aufruf Speicher für das Bildsignal anlegen müssen und den Algorithmus
 vollständig durchlaufen. In allen weiteren Schritten, wenn der Bildspeicher angelegt ist, wird der Algorithmus
 lediglich die Größe des Bildspeichers berechnen und vergleichen
 (Zeile \ref{alg:checkimagebuffer-size}--\ref{alg:checkimagebuffer-checksize-end}), was in konstanter Zeit erfolgt.

\autoref{alg:artkpfree} überprüft in Zeile \ref{alg:artkpfree-checkmem-start}--\ref{alg:artkpfree-checkmem-end} ob der
 Speicherbereich gültig ist. Falls nicht wird die weitere Ausführung abgebrochen. Nur im Falle, dass es sich um einen
 gültigen Speicherbereich handelt, wird in Zeile \ref{alg:artkpfree-deletemem-start}--\ref{alg:artkpfree-deletemem-end}
 der Speicher gelöscht und $\mathit{NULL}$ zugewiesen.

\input{alg/analyse-artplus/artkpfree}

\autoref{alg:artkpalloc} alloziert den Speicherbereich für die benötigte Größe, die in Zeile
 \ref{alg:checkimagebuffer-size} von \autoref{alg:checkimagebuffer} berechnet wurde.

\input{alg/analyse-artplus/artkpalloc}

Nachdem der Speicher das erste Mal angelegt wurde, werden weder \autoref{alg:artkpfree} noch \autoref{alg:artkpalloc}
 aufgerufen. Somit ist die Laufzeit, die zur Überprüfung der Größe des Bildspeichers verwendet wird, konstant.

% subsubsection bildspeicher (end)

% subsection datenstrukturen (end)

\subsection{Fiducial Detection} % (fold)
\label{sec:fiducial_detection}

Die \textit{Runtime Tracking Pipeline} (Vgl. \autoref{sub:artoolkitplus}, S.~\pageref{sub:artoolkitplus}) von
 ARToolKitPlus wird mit der Methode \textproc{calc} (Vgl. \autoref{alg:calc}) gestartet und benötigt das Bildsignal
 $I$, sowie den Schwellwert $\mathit{tresh}$. Die Methode \textproc{calc} dient in erster Linie als Einstiegspunkt der
 \textit{Runtime Tracking Pipeline}. Darum sind Verarbeitungsschritte die nicht zur Fiducial Detection gehören nicht
 aufgeführt.

\input{alg/analyse-artplus/calc}

Die Variablen $\mathit{marker\_info}$ und $\mathit{marker\_num}$ werden in Zeile
 \ref{alg:calc-init-start}--\ref{alg:calc-init-end} initialisiert. Bei $\mathit{marker\_info}$ handelt es sich um die
 Datenstruktur \textproc{MarkerInfo} (Vgl. \autoref{alg:datastructure-markerinfo}), die der Identifikation einer Marke
 dient. In Zeile \ref{alg:calc-check-image-start}--\ref{alg:calc-check-image-end} wird überprüft, ob das Bildsignal
 nicht $0$ ist und es sich somit um einen gesetzten Zeiger auf einen Speicherbereich handelt. Falls dies nicht der Fall
 ist, wird das Verfahren abgebrochen und ein Fehlerwert von $0$ zurückgeliefert. Anschliessend wird in Zeile
 \ref{alg:calc-start-detection-start}--\ref{alg:calc-start-detection-end} die Methode \textproc{arDetectMarker}
 aufgerufen und ihr Rückgabewert überprüft. Falls während der Ausführung von \textproc{arDetectMarker} einen Fehler
 aufgetreten ist, wird die weitere Verarbeitung gestoppt und ein Fehlerwert von $-1$ zurückgegeben. Wenn
 \textproc{arDetectMarker} erfolgreich war und eine Marke identifizieren konnte, wird die Verarbeitung fortgesetzt und
 letztendlich in Zeile \ref{alg:calc-identified-marker} eine Markenidentifizierung zurückgegeben. Die Laufzeit des
 Algorithmus ist konstant.

\textproc{arDetectMarker} (Vgl. \autoref{alg:detectmarker}) wird von \textproc{calc} aufgerufen und benötigt das
 Bildsignal $I$, den Schwellwert $\mathit{tresh}$ sowie $\mathit{marker\_info}$ und $\mathit{marker\_num}$. In Zeile
 \ref{alg:detectmarker-init-start}--\ref{alg:detectmarker-init-end} werden die lokalen Variablen initialisiert. Die
 Variablen werden als Parameter für den Aufruf der Methode \textproc{arDetectMarker2} in Zeile
 \ref{alg:detectmarker-call-method} verwendet.

\input{alg/analyse-artplus/detectmarker}

In Zeile \ref{alg:detectmarker-call-autothreshold} wird der Schwellwert auf seine Startwerte zurückgesetzt
 (Vgl. \autoref{alg:autothresholdreset}) und der Bildspeicher in Zeile \ref{alg:detectmarker-call-imagebuffer}
 überprüft (Vgl. \autoref{alg:checkimagebuffer}). Die Regionenmarkierung $I_l$ wird durch den Rückgabewert von
 \textproc{arLabeling} in Zeile \ref{alg:detectmarker-call-labeling} gesetzt. Im Anschluss wird in Zeile
 \ref{alg:detectmarker-check-il-start}--\ref{alg:detectmarker-check-il-end} geprüft, ob der Speicher der
 Regionenmarkierung erfolgreich gesetzt wurde. Andernfalls wird die Untersuchung für das aktuelle Bildsignal $I$
 beendet. Nur wenn die Regionenmarkierung erfolgreich war, wird in Zeile \ref{alg:detectmarker-call-method} die Methode
 \textproc{arDetectMarker2} aufgerufen. Der Rückgabewert von \textproc{arDetectMarker2} wird in der Membervariable
 $\mathit{marker\_info2}$ gespeichert. Es wird anschliessend in Zeile
 \ref{alg:detectmarker-check-marker-start}--\ref{alg:detectmarker-check-marker-end} geprüft, ob der Zeiger von
 $\mathit{marker\_info2}$ auf einen gültigen Speicherbereich verweist. Falls die Überprüfung erfolgreich war, sind in
 $\mathit{marker\_info2}$ die Koordinaten der Eckpunkte der Marke gespeichert und das Verfahren beendet.
 \autoref{alg:detectmarker} verarbeitet die Anweisungen in konstanter Zeit.

Die Methode \textproc{arLabeling} (\autoref{alg:arlabeling-init1}--\autoref{alg:}) wird zur Markierung der Regionen in
 einem Bildsignal $I$ verwendet. Wie in \autoref{sub:fiducial_detection} beschrieben, verzichet ARToolKitPlus beim
 Aufruf des Verfahrens auf ein Binärbild. Stattdessen wird ein Bildsignal $I$ während der Verarbeitung durch eine
 Schwellwertanalyse untersucht. \textproc{arLabeling} kann in drei Abschnitte unterteilt werden
 (Vgl. \autoref{alg:arlabeling-overview}):

\begin{enumerate}
	\item Initialisierung der Variablen und des Speichers, \label{label-init}
	\item Regionenmarkierung und Auflösen von Kollisionen und \label{label-region}
	\item Aufbereiten der Regionenmarkierung zur Speicherung. \label{label-cleaning}
\end{enumerate}

\input{alg/analyse-artplus/arlabeling-overview}

\autoref{label-init} ist in \autoref{alg:arlabeling-init1} aufgeführt. In Zeile
 \ref{alg:arlabeling-init1-local-start}--\ref{alg:arlabeling-init1-local-end} werden die lokalen Variablen deklariert,
 deren Bedeutung bei ihrem ersten Auftreten erklärt werden. Speicheradressen werden in Zeile
 \ref{alg:arlabeling-init1-address-start}--\ref{alg:arlabeling-init1-address-end} initialisiert. Der
 Schwellwertparameter wird verdreifacht und in lokal gespeichert (Zeile \ref{alg:arlabeling-init1-threshold}). Die
 Schwellwertanalyse in \autoref{alg:} benutzt einen dreifachen Wert als Optimierung
 (Vgl. S.~\autoref{sub:}). Zum Schluss wird in Zeile
 \ref{alg:arlabeling-init1-size-start}--\ref{alg:arlabeling-init1-size-end} die Größe des Bildsignals festgelegt. Die
 Variablen $\mathit{arImXsize}$ und $\mathit{arImYsize}$ enthalten die die Breite und Höhe des Bildsignals $I$. Das
 halbieren der Bildhöhe und -breite ist ebenfalls eine Optimierung. Da auf alle Variablen und Adressen direkt
 zugegriffen wird, ist die Laufzeit des Algorithmus konstant.

\input{alg/analyse-artplus/arlabeling-init1}

Die Initialisierung von \textproc{arLabeling} wird in \autoref{alg:arlabeling-init2} fortgesetzt. $\mathit{pnt1}$ wird
 in Zeile \ref{alg:arlabeling-init2-address1-start} auf die erste Speicherstelle der ersten Zeile des Regionenbildes
 gesetzt. $\mathit{pnt2}$ erhält in Zeile \ref{alg:arlabeling-init2-address1-end} die erste Speicherstelle der
 letzten Zeile des Regionenbildes. In der Schleife in Zeile
 \ref{alg:arlabeling-init2-loop1-start}--\ref{alg:arlabeling-init2-loop1-end} wird über die Breite des Regionenbildes
 iteriert, um die erste und die letzte Zeile des Regionenbildes zu löschen. Dazu wird an den Adressen von
 $\mathit{pnt1}$ und $\mathit{pnt2}$ der Wert $0$ gespeichert. Danach werden die Adressen von $\mathit{pnt1}$ und
 $\mathit{pnt2}$ inkrementiert. In Zeile \ref{alg:arlabeling-init2-inc-1} wird die Laufvariable $i$ inkrementiert.

\input{alg/analyse-artplus/arlabeling-init2}

In Zeile \ref{alg:arlabeling-init2-address2-start}--\ref{alg:arlabeling-init2-address2-end} werden die Adressen
 von $\mathit{pnt1}$ und $\mathit{pnt2}$ erneut festgelegt. $\mathit{pnt1}$ wird die erste Speicherstelle des
 Regionenbildes zugewiesen. In $\mathit{pnt2}$ wird die Adresse der ersten Speicherstelle der letzten Zeile hinterlegt.
 In der Schleife von Zeile \ref{alg:arlabeling-init2-loop2-start}--\ref{alg:arlabeling-init2-loop2-end} wird die erste
 und letzte Spalte des Regionenbildes gelöscht, indem der Wert $0$ an die Speicherstelle von $\mathit{pnt1}$ und
 $\mathit{pnt2}$ geschrieben wird
 (Zeile \ref{alg:arlabeling-init2-clearfirstrow}--\ref{alg:arlabeling-init2-clearlastrow}). Im Anschluss daran werden
 die Adressen $\mathit{pnt1}$ und $\mathit{pnt2}$, sowie die Laufvariable $i$, inkrementiert.

In Zeile \ref{alg:arlabeling-init2-label} wird die Markierungsvariable $\mathit{wk\_max}$ mit dem Wert $0$
 initialisiert. Danach wird die Adresse der Startposition des Regionenbildes in $\mathit{pnt2}$ gespeichert. Dabei ist
 zu beachten, dass die Adresse auf den zweiten \gls{pixel} der zweiten Zeile verweist. $\mathit{pnt}$ wird daraufhin die
 Adresse des Bildsignals $I$ zugewiesen. Der Adresse von $I$ ist der vierte \gls{pixel} der zweiten Zeile. Die
 Variable $\mathit{poff}$ ist der Adressabstand der \gls{pixel} in $I$ und dient der Adressierung des nächsten
 \glspl{pixel}. $\mathit{poff}$ wird in der letzten Zeile von \autoref{alg:arlabeling-init2} gesetzt.

Die Kosten des Algorithmus sind in \autoref{alg:arlabeling-init2} angegeben und in \autoref{eq:analyse-arlabeling} aufgeführt. Die Laufzeit des Algorithmus ist abhängig von der Breite $\mathit{lxsize}$ des Regionenbildes und beträgt $\Theta{(\mathit{lxsize})}$.

\begin{equation}
	\label{eq:analyse-arlabeling}
	\begin{split}
		T(I) = &
		c_1
		+ c_2
		+ c_3 \left(\mathit{lxsize} + 1\right)\\
		& + c_4 \sum_{i=1}^{\mathit{lxsize}} 1
		+ c_5 \sum_{i=1}^{\mathit{lxsize}} 1
		+ c_6 \sum_{i=1}^{\mathit{lxsize}} 1
		+ c_7 \sum_{i=1}^{\mathit{lxsize}} 1
		+ c_8 \sum_{i=1}^{\mathit{lxsize}} 1\\
		& + c_9
		+ c_{10}
		+ c_{11} \left(\mathit{lysize} + 1\right)\\
		& + c_{12} \sum_{i=1}^{\mathit{lysize}} 1
		+ c_{13} \sum_{i=1}^{\mathit{lysize}} 1
		+ c_{14} \sum_{i=1}^{\mathit{lysize}} 1
		+ c_{15} \sum_{i=1}^{\mathit{lysize}} 1
		+ c_{16} \sum_{i=1}^{\mathit{lysize}} 1\\
		& + c_{17}
		+ c_{18}
		+ c_{19}
		+ c_{20}\\
		T(I) = &
		c_1
		+ c_2
		+ c_3
		+ \left(c_3 \mathit{lxsize}\right)\\
		& + c_4 \left[ \mathit{lxsize} \left(1\right) \right]
		+ c_5 \left[ \mathit{lxsize} \left(1\right) \right]
		+ c_6 \left[ \mathit{lxsize} \left(1\right) \right]
		+ c_7 \left[ \mathit{lxsize} \left(1\right) \right]
		+ c_8 \left[ \mathit{lxsize} \left(1\right) \right]\\
		& + c_9
		+ c_{10}
		+ c_{11}
		+ c_{11} \left[ \mathit{lysize} \left(1\right) \right]\\
		& + c_{12} \left[ \mathit{lysize} \left(1\right) \right]
		+ c_{13} \left[ \mathit{lysize} \left(1\right) \right]
		+ c_{14} \left[ \mathit{lysize} \left(1\right) \right]
		+ c_{15} \left[ \mathit{lysize} \left(1\right) \right]
		+ c_{16} \left[ \mathit{lysize} \left(1\right) \right]\\
		& + c_{17}
		+ c_{18}
		+ c_{19}
		+ c_{20}\\
		T(I) = &
		c_1
		+ c_2
		+ c_3
		+ \left( c_3 + c_4 + c_5 + c_6 + c_7 + c_8 \right) \mathit{lxsize}\\
		& + c_9
		+ c_{10}
		+ c_{11}
		+ \left( c_{11} + c_{12} + c_{13} + c_{14} + c_{15} + c_{16} \right) \mathit{lysize}\\
		& + c_{17}
		+ c_{18}
		+ c_{19}
		+ c_{20}\\
		T(I) = &
		\mathit{lxsize} + \mathit{lysize}\\
		T(I) = &
		\Theta\left( \mathit{lxsize} \right)
	\end{split}
\end{equation}

% subsection fiducial_detection (end)

\subsection{Rectangle Fitting} % (fold)
\label{sec:rectangle_fitting}

% subsection rectangle_fitting (end)

% section artoolkitplus (end)

