\section{ARToolKitPlus} % (fold)
\label{sec:artoolkitplus}

\subsection{Datenstrukturen} % (fold)
\label{sec:datenstrukturen}

ARToolKitPlus speichert die Informationen einer Marke in zwei einfachen Datenstrukturen. Informationen zur
 Identifizierung einer Marke werden in \textproc{MarkerInfo} gespeichert (\autoref{alg:datastructure-markerinfo}) und
 Informationen zur Erkennung einer Marke werden in \textproc{MarkerInfo2} gespeichert
 (\autoref{alg:datastructure-markerinfo2}). Da \textproc{MarkerInfo} zur Identifizierung einer Marke verwendet wird,
 werde ich diese Datenstruktur nur zur Vollständigkeit erwähnen. Das Identifikationsmerkmal $\mathit{id}$ wird in
 \autoref{alg:calc} als Rückgabewert verwendet.

\input{alg/analyse-artplus/datastructure-markerinfo}

\subsubsection{MakerInfo2} % (fold)
\label{sec:makerinfo2}

Die Variable $\mathit{area}$ speichert den Flächeninhalt einer Marke, während $\mathit{pos}[2]$ die Position des
 Zentrums der Marke enthält. $\mathit{coord\_num}$ enthält die Anzahl der gefundenen Konturpixel, die in
 $\mathit{x\_coord}$ als $x$-Koordinate und in $\mathit{y\_coord}$ als $y$-Koordinate gespeichert sind. Die konstante
 Größe $\mathit{AR\_CHAIN\_MAX}$ des Speichers für die Koordinaten wird zur Laufzeit nicht verändert. ARToolKitPlus
 erlaubt maximal $10000$ Einträge für Koordinaten pro Marke. Die Eckpunkte einer Marke sind in $\mathit{x\_coord}$ und
 $\mathit{y\_coord}$ enthalten und werden durch einen Index in $\mathit{vertex}$ referenziert. Hierbei ist zu beachten,
 dass $\mathit{vertex}$ fünf Einträge speichert, wobei der erste und letzte Eintrag auf die gleiche Koordinate
 verweisen. Dadurch kann bei der Grafikprogrammierung mit OpenGL sehr einfach ein Rahmen um eine Marke gezeichnet
 werden.

\input{alg/analyse-artplus/datastructure-markerinfo2}

Der Zugriff auf die Variablen der Datenstruktur, sowohl lesend als auch schreibend, ist konstant.

% subsubsection makerinfo2 (end)

\subsubsection{Automatischer Schwellwert} % (fold)
\label{sec:automatischer_schwellwert}

Die automatische Schwellwertanalyse von ARToolKitPlus wird durch \autoref{alg:autothresholdreset} vor ihrer Verwendung
 auf bekannte Startwerte gesetzt. Dabei wird in Zeile \ref{alg:autothresholdreset-minLum} die globale Variable
 $\mathit{minLum}$ gesetzt und in Zeile \ref{alg:autothresholdreset-maxLum} die globale Variable $\mathit{maxLum}$
 gesetzt. Die statischen Größen $\mathit{MINLUM0}$ und $\mathit{MAXLUM0}$ geben dabei die Werte an. Die Laufzeit von
 \autoref{alg:autothresholdreset} ist konstant.

\input{alg/analyse-artplus/autothresholdreset}

% subsubsection automatischer_schwellwert (end)

\subsubsection{Bildspeicher} % (fold)
\label{sec:bildspeicher}

Die Algorithmen zur Verwaltung des Bildspeichers werden zur Vollständigkeit erwähnt. Da die folgenden Algorithmen
 einmalig vor den Verfahren der Markenerkennung ausgeführt werden, haben sie auf die Analyse keinen Einfluß.

\autoref{alg:checkimagebuffer} ist beim Initialisieren der \textit{Runtime Tracking Pipeline} für die Bereitstellung
 des Bildspeichers zuständig. In Zeile \ref{alg:checkimagebuffer-size} wird die Größe des Eingangssignals mit Hilfe der
 globalen Variablen errechnet. Danach wird in Zeile
 \ref{alg:checkimagebuffer-checksize-start}--\ref{alg:checkimagebuffer-checksize-end} die errechnete Größe mit der
 Größe der globalen Variable verglichen. Wenn die Größe nicht übereinstimmt, wird in Zeile
 \ref{alg:checkimagebuffer-checkmem-start}--\ref{alg:checkimagebuffer-checkmem-end} überprüft, ob der Speicher für ein
 Bild bereits gesetzt ist. Falls der Speicherbereich schon gesetzt ist, muss er mit \autoref{alg:artkpfree} gelöscht
 werden. In Zeile \ref{alg:checkimagebuffer-sizeglobal} wird der globalen Variable die berechnete Größe des
 Bildspeichers zugewiesen. Zuletzt wird der globalen Variable des Bildspeichers ein neuer Speicherbereich in Zeile
 \ref{alg:checkimagebuffer-newmem} zugewiesen.

\input{alg/analyse-artplus/checkimagebuffer}

\autoref{alg:checkimagebuffer} wird beim ersten Aufruf Speicher für das Bildsignal anlegen müssen und den Algorithmus
 vollständig durchlaufen. In allen weiteren Schritten, wenn der Bildspeicher angelegt ist, wird der Algorithmus
 lediglich die Größe des Bildspeichers berechnen und vergleichen
 (Zeile \ref{alg:checkimagebuffer-size}--\ref{alg:checkimagebuffer-checksize-end}), was in konstanter Zeit erfolgt.

\autoref{alg:artkpfree} überprüft in Zeile \ref{alg:artkpfree-checkmem-start}--\ref{alg:artkpfree-checkmem-end} ob der
 Speicherbereich gültig ist. Falls nicht wird die weitere Ausführung abgebrochen. Nur im Falle, dass es sich um einen
 gültigen Speicherbereich handelt, wird in Zeile \ref{alg:artkpfree-deletemem-start}--\ref{alg:artkpfree-deletemem-end}
 der Speicher gelöscht und $\mathit{NULL}$ zugewiesen.

\input{alg/analyse-artplus/artkpfree}

\autoref{alg:artkpalloc} alloziert den Speicherbereich für die benötigte Größe, die in Zeile
 \ref{alg:checkimagebuffer-size} von \autoref{alg:checkimagebuffer} berechnet wurde.

\input{alg/analyse-artplus/artkpalloc}

Nachdem der Speicher das erste Mal angelegt wurde, werden weder \autoref{alg:artkpfree} noch \autoref{alg:artkpalloc}
 aufgerufen. Somit ist die Laufzeit, die zur Überprüfung der Größe des Bildspeichers verwendet wird, konstant.

% subsubsection bildspeicher (end)

% subsection datenstrukturen (end)

\subsection{Fiducial Detection} % (fold)
\label{sec:fiducial_detection}

Die \textit{Runtime Tracking Pipeline} (Vgl. \autoref{sub:artoolkitplus}, S.~\pageref{sub:artoolkitplus}) von
 ARToolKitPlus wird mit der Methode \textproc{calc} (Vgl. \autoref{alg:calc}) gestartet und benötigt das Bildsignal
 $I$, sowie den Schwellwert $\mathit{tresh}$. Die Methode \textproc{calc} dient in erster Linie als Einstiegspunkt der
 \textit{Runtime Tracking Pipeline}. Darum sind Verarbeitungsschritte die nicht zur Fiducial Detection gehören nicht
 aufgeführt.

\input{alg/analyse-artplus/calc}

Die Variablen $\mathit{marker\_info}$ und $\mathit{marker\_num}$ werden in Zeile
 \ref{alg:calc-init-start}--\ref{alg:calc-init-end} initialisiert. Bei $\mathit{marker\_info}$ handelt es sich um die
 Datenstruktur \textproc{MarkerInfo} (Vgl. \autoref{alg:datastructure-markerinfo}), die der Identifikation einer Marke
 dient. In Zeile \ref{alg:calc-check-image-start}--\ref{alg:calc-check-image-end} wird überprüft, ob das Bildsignal
 nicht $0$ ist und es sich somit um einen gesetzten Zeiger auf einen Speicherbereich handelt. Falls dies nicht der Fall
 ist, wird das Verfahren abgebrochen und ein Fehlerwert von $0$ zurückgeliefert. Anschliessend wird in Zeile
 \ref{alg:calc-start-detection-start}--\ref{alg:calc-start-detection-end} die Methode \textproc{arDetectMarker}
 aufgerufen und ihr Rückgabewert überprüft. Falls während der Ausführung von \textproc{arDetectMarker} einen Fehler
 aufgetreten ist, wird die weitere Verarbeitung gestoppt und ein Fehlerwert von $-1$ zurückgegeben. Wenn
 \textproc{arDetectMarker} erfolgreich war und eine Marke identifizieren konnte, wird die Verarbeitung fortgesetzt und
 letztendlich in Zeile \ref{alg:calc-identified-marker} eine Markenidentifizierung zurückgegeben. Die Laufzeit des
 Algorithmus ist konstant.

\textproc{arDetectMarker} (Vgl. \autoref{alg:detectmarker}) wird von \textproc{calc} aufgerufen und benötigt das
 Bildsignal $I$, den Schwellwert $\mathit{tresh}$ sowie $\mathit{marker\_info}$ und $\mathit{marker\_num}$. In Zeile
 \ref{alg:detectmarker-init-start}--\ref{alg:detectmarker-init-end} werden die lokalen Variablen initialisiert. Die
 Variablen werden als Parameter für den Aufruf der Methode \textproc{arDetectMarker2} in Zeile
 \ref{alg:detectmarker-call-method} verwendet.

\input{alg/analyse-artplus/detectmarker}

In Zeile \ref{alg:detectmarker-call-autothreshold} wird der Schwellwert auf seine Startwerte zurückgesetzt
 (Vgl. \autoref{alg:autothresholdreset}) und der Bildspeicher in Zeile \ref{alg:detectmarker-call-imagebuffer}
 überprüft (Vgl. \autoref{alg:checkimagebuffer}). Die Regionenmarkierung $I_l$ wird durch den Rückgabewert von
 \textproc{arLabeling} in Zeile \ref{alg:detectmarker-call-labeling} gesetzt. Im Anschluss wird in Zeile
 \ref{alg:detectmarker-check-il-start}--\ref{alg:detectmarker-check-il-end} geprüft, ob der Speicher der
 Regionenmarkierung erfolgreich gesetzt wurde. Andernfalls wird die Untersuchung für das aktuelle Bildsignal $I$
 beendet. Nur wenn die Regionenmarkierung erfolgreich war, wird in Zeile \ref{alg:detectmarker-call-method} die Methode
 \textproc{arDetectMarker2} aufgerufen. Der Rückgabewert von \textproc{arDetectMarker2} wird in der Membervariable
 $\mathit{marker\_info2}$ gespeichert. Es wird anschliessend in Zeile
 \ref{alg:detectmarker-check-marker-start}--\ref{alg:detectmarker-check-marker-end} geprüft, ob der Zeiger von
 $\mathit{marker\_info2}$ auf einen gültigen Speicherbereich verweist. Falls die Überprüfung erfolgreich war, sind in
 $\mathit{marker\_info2}$ die Koordinaten der Eckpunkte der Marke gespeichert und das Verfahren beendet.
 \autoref{alg:detectmarker} verarbeitet die Anweisungen in konstanter Zeit.

Die Methode \textproc{arLabeling} (\autoref{alg:arlabeling-init1}--\autoref{alg:arlabeling-neighbour-case5}) wird zur
 Markierung der Regionen in einem Bildsignal $I$ verwendet. Wie in \autoref{sub:fiducial_detection} beschrieben,
 verzichet ARToolKitPlus beim Aufruf des Verfahrens auf ein Binärbild. Stattdessen wird ein Bildsignal $I$ während der
 Verarbeitung durch eine Schwellwertanalyse untersucht. \textproc{arLabeling} kann in drei Abschnitte unterteilt werden
 (Vgl. \autoref{alg:arlabeling-overview}):

\begin{enumerate}
	\item Initialisierung der Variablen und des Speichers, \label{label-init}
	\item Regionenmarkierung und Auflösen von Kollisionen und \label{label-region}
	\item Aufbereiten der Regionenmarkierung zur Speicherung. \label{label-cleaning}
\end{enumerate}

\input{alg/analyse-artplus/arlabeling-overview}

\autoref{label-init} ist in \autoref{alg:arlabeling-init1} aufgeführt. In Zeile
 \ref{alg:arlabeling-init1-local-start}--\ref{alg:arlabeling-init1-local-end} werden die lokalen Variablen deklariert,
 deren Bedeutung bei ihrem ersten Auftreten erklärt werden. Speicheradressen werden in Zeile
 \ref{alg:arlabeling-init1-address-start}--\ref{alg:arlabeling-init1-address-end} initialisiert. Der
 Schwellwertparameter wird verdreifacht und in lokal gespeichert (Zeile \ref{alg:arlabeling-init1-threshold}). Die
 Schwellwertanalyse in \autoref{alg:arlabeling-regionlabeling} benutzt einen dreifachen Wert als Optimierung
 (Vgl. S.~\pageref{sub:arlabel-threshold}). Zum Schluss wird in Zeile
 \ref{alg:arlabeling-init1-size-start}--\ref{alg:arlabeling-init1-size-end} die Größe des Bildsignals festgelegt. Die
 Variablen $\mathit{arImXsize}$ und $\mathit{arImYsize}$ enthalten die Breite und Höhe des Bildsignals $I$. Das
 halbieren der Bildhöhe und -breite ist ebenfalls eine Optimierung. Da auf alle Variablen und Adressen direkt
 zugegriffen wird, ist die Laufzeit des Algorithmus konstant.

\input{alg/analyse-artplus/arlabeling-init1}

Die Initialisierung von \textproc{arLabeling} wird in \autoref{alg:arlabeling-init2} fortgesetzt. $\mathit{pnt1}$ wird
 in Zeile \ref{alg:arlabeling-init2-address1-start} auf die erste Speicherstelle der ersten Zeile des Regionenbildes
 gesetzt. $\mathit{pnt2}$ erhält in Zeile \ref{alg:arlabeling-init2-address1-end} die erste Speicherstelle der
 letzten Zeile des Regionenbildes. In der Schleife in Zeile
 \ref{alg:arlabeling-init2-loop1-start}--\ref{alg:arlabeling-init2-loop1-end} wird über die Breite des Regionenbildes
 iteriert, um die erste und die letzte Zeile des Regionenbildes zu löschen. Dazu wird an den Adressen von
 $\mathit{pnt1}$ und $\mathit{pnt2}$ der Wert $0$ gespeichert. Danach werden die Adressen von $\mathit{pnt1}$ und
 $\mathit{pnt2}$ inkrementiert. In Zeile \ref{alg:arlabeling-init2-inc-1} wird die Laufvariable $i$ inkrementiert.

\input{alg/analyse-artplus/arlabeling-init2}

In Zeile \ref{alg:arlabeling-init2-address2-start}--\ref{alg:arlabeling-init2-address2-end} werden die Adressen
 von $\mathit{pnt1}$ und $\mathit{pnt2}$ erneut festgelegt. $\mathit{pnt1}$ wird die erste Speicherstelle des
 Regionenbildes zugewiesen. In $\mathit{pnt2}$ wird die Adresse der ersten Speicherstelle der letzten Zeile hinterlegt.
 In der Schleife von Zeile \ref{alg:arlabeling-init2-loop2-start}--\ref{alg:arlabeling-init2-loop2-end} wird die erste
 und letzte Spalte des Regionenbildes gelöscht, indem der Wert $0$ an die Speicherstelle von $\mathit{pnt1}$ und
 $\mathit{pnt2}$ geschrieben wird
 (Zeile \ref{alg:arlabeling-init2-clearfirstrow}--\ref{alg:arlabeling-init2-clearlastrow}). Im Anschluss daran werden
 die Adressen $\mathit{pnt1}$ und $\mathit{pnt2}$, sowie die Laufvariable $i$, inkrementiert.

In Zeile \ref{alg:arlabeling-init2-label} wird die Markierungsvariable $\mathit{wk\_max}$ mit dem Wert $0$
 initialisiert. Danach wird die Adresse der Startposition des Regionenbildes in $\mathit{pnt2}$ gespeichert. Dabei ist
 zu beachten, dass die Adresse auf den zweiten \gls{pixel} der zweiten Zeile verweist. $\mathit{pnt}$ wird daraufhin die
 Adresse des Bildsignals $I$ zugewiesen. Der Adresse von $I$ ist der vierte \gls{pixel} der zweiten Zeile. Die
 Variable $\mathit{poff}$ ist der Adressabstand der \gls{pixel} in $I$ und dient der Adressierung des nächsten
 \glspl{pixel}. $\mathit{poff}$ wird in der letzten Zeile von \autoref{alg:arlabeling-init2} gesetzt.

Die Kosten des Algorithmus sind in \autoref{alg:arlabeling-init2} angegeben und in \autoref{eq:analyse-arlabeling}
 aufgeführt. Da die Breite $\mathit{lxsize}$ des Regionenbildes größer ist als die Höhe $\mathit{lysize}$, ist die
 Laufzeit des Algorithmus abhängig von $\mathit{lxsize}$ und beträgt somit $\Theta{(\mathit{lxsize})}$.

\begin{equation}
	\label{eq:analyse-arlabeling}
	\begin{split}
		T(I) = &
		c_1
		+ c_2
		+ c_3 \left(\mathit{lxsize} + 1\right)\\
		& + c_4 \sum_{i=1}^{\mathit{lxsize}} 1
		+ c_5 \sum_{i=1}^{\mathit{lxsize}} 1
		+ c_6 \sum_{i=1}^{\mathit{lxsize}} 1
		+ c_7 \sum_{i=1}^{\mathit{lxsize}} 1
		+ c_8 \sum_{i=1}^{\mathit{lxsize}} 1\\
		& + c_9
		+ c_{10}
		+ c_{11} \left(\mathit{lysize} + 1\right)\\
		& + c_{12} \sum_{i=1}^{\mathit{lysize}} 1
		+ c_{13} \sum_{i=1}^{\mathit{lysize}} 1
		+ c_{14} \sum_{i=1}^{\mathit{lysize}} 1
		+ c_{15} \sum_{i=1}^{\mathit{lysize}} 1
		+ c_{16} \sum_{i=1}^{\mathit{lysize}} 1\\
		& + c_{17}
		+ c_{18}
		+ c_{19}
		+ c_{20}\\
		T(I) = &
		c_1
		+ c_2
		+ c_3
		+ \left(c_3 \mathit{lxsize}\right)\\
		& + c_4 \left[ \mathit{lxsize} \left(1\right) \right]
		+ c_5 \left[ \mathit{lxsize} \left(1\right) \right]
		+ c_6 \left[ \mathit{lxsize} \left(1\right) \right]
		+ c_7 \left[ \mathit{lxsize} \left(1\right) \right]
		+ c_8 \left[ \mathit{lxsize} \left(1\right) \right]\\
		& + c_9
		+ c_{10}
		+ c_{11}
		+ c_{11} \left[ \mathit{lysize} \left(1\right) \right]\\
		& + c_{12} \left[ \mathit{lysize} \left(1\right) \right]
		+ c_{13} \left[ \mathit{lysize} \left(1\right) \right]
		+ c_{14} \left[ \mathit{lysize} \left(1\right) \right]
		+ c_{15} \left[ \mathit{lysize} \left(1\right) \right]
		+ c_{16} \left[ \mathit{lysize} \left(1\right) \right]\\
		& + c_{17}
		+ c_{18}
		+ c_{19}
		+ c_{20}\\
		T(I) = &
		c_1
		+ c_2
		+ c_3
		+ \left( c_3 + c_4 + c_5 + c_6 + c_7 + c_8 \right) \mathit{lxsize}\\
		& + c_9
		+ c_{10}
		+ c_{11}
		+ \left( c_{11} + c_{12} + c_{13} + c_{14} + c_{15} + c_{16} \right) \mathit{lysize}\\
		& + c_{17}
		+ c_{18}
		+ c_{19}
		+ c_{20}\\
		T(I) = &
		\mathit{lxsize} + \mathit{lysize}\\
		T(I) = &
		\Theta\left( \mathit{lxsize} \right)
	\end{split}
\end{equation}

\autoref{label-region} von \autoref{alg:arlabeling-overview} ist für die Regionenmarkierung und das Auflösen von
 Kollisionen verantwortlich. Eine Übersich des Verfahrens ist in \autoref{alg:arlabeling-regionlabeling} dargestellt.
 \textproc{arLabeling} untersucht das Bildsignal $I$ zeilenweise von links oben nach rechts unten. Durch eine
 Schwellwertanalyse wird entschieden, ob ein \gls{pixel} an Position $I(u,v)$ ein Vordergrund- oder Hintergrundpixel
 ist. Die Regionenmarkierung wird dann in $\mathit{l\_image}$ gespeichert. Das Verfahren wird solange wiederholt, bis
 das Bildsignal $I$ vollständig prozessiert wurde und zusammenhängende Bildregionen in $\mathit{l\_image}$ markiert
 sind. Die Variable $\mathit{pnt}$ enthält die Adresse des zu untersuchenden \gls{pixel} aus $I$. Die nächste freie
 Speicherstelle in $\mathit{l\_image}$ ist in $\mathit{pnt2}$ hinterlegt.

\input{alg/analyse-artplus/arlabeling-regionlabeling}

In den beiden Schleifen in Zeile
 \ref{alg:arlabeling-regionlabeling-loop1-start}--\ref{alg:arlabeling-regionlabeling-loop1-end} und Zeile
 \ref{alg:arlabeling-regionlabeling-loop2-start}--\ref{alg:arlabeling-regionlabeling-loop2-end} wird das Bildsignal
 zeilenweise, von oben links nach unten rechts, verarbeitet. Das Inkrementieren der Variablen in Zeile
 \ref{alg:arlabeling-regionlabeling-inc1-start}--\ref{alg:arlabeling-regionlabeling-inc1-end} und Zeile
 \ref{alg:arlabeling-regionlabeling-inc2-start}--\ref{alg:arlabeling-regionlabeling-inc2-end} sorgt dafür, dass nur die
 Hälfte der \gls{pixel} prozessiert werden.

Die Schwellwertanalyse wird in Zeile
 \ref{alg:arlabeling-regionlabeling-threshold-start}--\ref{alg:arlabeling-regionlabeling-threshold-end} durchgeführt.
 Dazu wird in Zeile \ref{alg:arlabeling-regionlabeling-calcblack} die RGB-Komponente des Bildsignals $I$ ausgelesen und
 addiert. Normalerweise würde man an dieser Stelle den Schwellwert mit jeder Komponente $R$, $G$ und $B$ einzeln
 vergleichen. Die Verdreifachung des Schwellwerts in \autoref{alg:arlabeling-init1} und die Addition der
 RGB-Komponenten ermöglichen hingegen eine Schwellwertanalyse mit nur einem Vergleich.\label{sub:arlabel-threshold}

In Zeile \ref{alg:arlabeling-regionlabeling-isblack?}--\ref{alg:arlabeling-regionlabeling-threshold-end} wird
 untersucht, ob ein Vordergrundpixel gefunden wurde. Falls nicht, wird in das Regionenbild $\mathit{l\_image}$ eine $0$
 geschrieben. Wenn die Schwellertanalyse ein Vordergrundpixel bestimmt hat, müssen in Zeile
 \ref{alg:arlabeling-regionlabeling-black} die Nachbarn des Vordergrundpixels mit einer 8er-Nachbarschaft untersucht
 werden (Vgl. \autoref{alg:arlabeling-neighbour}).

\input{alg/analyse-artplus/arlabeling-neighbour}

Die Nachbarschafsuntersuchung in ARToolKitPlus untersucht die vier Nachbarn der Markierung an Position $I(u,v)$. Wie in
 \autoref{sec:vorläufige_makierung} bereits beschrieben, ist eine Regionenmarkierung davon abhängig ob alle Nachbarn
 Hintergrundpixel sind, genau ein Nachbar eine Markierung hat oder mehrere Nachbarn eine Markierung haben. Die Fälle
 1, 3 und 4 in \autoref{alg:arlabeling-neighbour} untersuchen, ob genau ein Nachbar eine Markierung hat. Bei Fall 5 sind
 alle Nachbarn Hintergrundpixel. Nur bei Fall 2 können  mehrere Nachbarn eine Markierung haben. In Zeile
 \ref{alg:arlabeling-neighbour-n3} wird der Variablen $\mathit{pnt1}$ der Nachbar $N_3 = (u,v+1)$ zugewiesen. Die
 Nachbarn sind in \autoref{fig:analyse-nachbarschaftsbeziehung} illustriert.

\begin{figure}[!ht]
	\centering
	\input{resources/8er-Nachbarschaft.pdf_tex}
	\caption{8er-Nachbarschaft mit $N_1 = I(u-1,v)$, $N_2 = I(u-1,v+1)$, $N_3 = (u,v+1)$ und $N_4 = I(u+1,v+1)$.}
	\label{fig:analyse-nachbarschaftsbeziehung}
\end{figure}

\paragraph{1. Fall:} % (fold)
\label{par:fall_1_}
Wir wissen durch \autoref{alg:arlabeling-regionlabeling}, dass $I(u,v)$ ein Vordergrundpixel ist, dem wir an dieser
 Stelle eine Markierung zuweisen wollen. Im ersten Fall wird die Markierung $N_3$ untersucht. Wenn $N_3$ ein
 Vordergrundpixel ist kann die Markierung für $I(u,v)$ übernommen werden. Falls es sich bei den Nachbarn
 $N_1 = I(u-1,v)$, $N_2 = I(u-1,v+1)$ und $N_4 = I(u+1,v+1)$ um Vordergrundpixel handelt, haben sie die gleiche
 Markierung wie $N_3$ und müssen nicht weiter untersucht werden. Das Verfahren ist in
 \autoref{alg:arlabeling-neighbour-case1} beschrieben.

\input{alg/analyse-artplus/arlabeling-neighbour-case1}

In Zeile \ref{alg:arlabeling-neighbour-case1-save-label} wird die Markierung von $N_3$ übernommen und in
 $\mathit{l\_image}$ an Position $(x,y)$ gespeichert. In der Variablen $\mathit{work2}$ werden Informationen der
 Regionenmarkierung gespeichert. Dazu wird zuerst in Zeile \ref{alg:arlabeling-neighbour-case1-calc-offset} aus
 $\mathit{pnt2}$ der Wert der Regionenmarkierung gelesen. Der Wert der Markierung wird zur Berechnung des
 Adressabstands benutzt, um die Werte für die Region an die richtige Stelle zu schreiben. An der Position $0$ von
 $\mathit{work2}$ (Zeile \ref{alg:arlabeling-neighbour-case1-inc-region}) wird die Anzahl der Vordergrundpixel der
 Region erhöht. Position 1 und Position 2 von $\mathit{work2}$ enthalten die akummulierten Werte von $i$ und $j$ für
 die u- und v-Koordinaten aller Vordergrundpixel der Region. An Position 6 von $\mathit{work2}$ in Zeile
 \ref{alg:arlabeling-neighbour-case1-save-j} wird die y-Koordinate gespeichert. Alle Anweisungen in
 \autoref{alg:arlabeling-neighbour-case1} werden in konstanter Zeit ausgeführt.

% paragraph fall_1_ (end)

\paragraph{2. Fall:} % (fold)
\label{par:fall_2_}
Beim zweiten Fall wird die Markierung $N_4$ betrachtet. Da $N_3$ keine Markierung aufweist, können nur $N_1$ und $N_2$
 Markierungen haben. Da die Markierungen nur durch $I(u,v)$ verbunden sind, kann es sich hier um eine Kollision
 handeln, die durch \autoref{alg:arlabeling-neighbour-case2-1} oder \autoref{alg:arlabeling-neighbour-case2-2}
 besonders behandelt wird. Das Verfahren ist in \autoref{alg:arlabeling-neighbour-case2} aufgeführt.

\input{alg/analyse-artplus/arlabeling-neighbour-case2}

In Zeile \ref{alg:arlabeling-neighbour-case2-n2} wird überprüft, ob $N_2$ eine Markierung enthält. Falls ja, wird
 \autoref{alg:arlabeling-neighbour-case2-1} untersuchen, ob eine Kollision vorliegt und sie gegebenfalls auflösen.
 Zeile \ref{alg:arlabeling-neighbour-case2-n1} überprüft $N_1$ auf eine vorhandene Markierung und fährt mit der
 Untersuchung einer evtl. Kollision in \autoref{alg:arlabeling-neighbour-case2-2} fort. Wenn weder $N_2$ noch $N_1$
 eine Markierung haben, ist nur $N_4$ ein Vordergrundpixel und wird mit \autoref{alg:arlabeling-neighbour-case2-3}
 markiert.

\input{alg/analyse-artplus/arlabeling-neighbour-case2-1}

In \autoref{alg:arlabeling-neighbour-case2-1} wird in Zeile \ref{alg:arlabeling-neighbour-case2-1-m} der Wert der
 Markierung $N_4$ in Variable $m$ gespeichert. In Zeile \ref{alg:arlabeling-neighbour-case2-1-n} wird der Wert $N_2$
 in $n$ hinterlegt. In Zeile \ref{alg:arlabeling-neighbour-case2-mn-start}--\ref{alg:arlabeling-neighbour-case2-mn-end}
 wird überprüft, ob $m$ größer als $n$ ist. Falls dem so ist, wird der Wert $n$ in $\mathit{l\_image}$ gespeichert
 (Zeile \ref{alg:arlabeling-neighbour-case2-saven}). Danach wird in Zeile \ref{alg:arlabeling-neighbour-case2-worklist}
 die Adresse der ersten Stelle der Regionenmarkierungsliste $\mathit{work}$ in $wk$ hinterlegt. In der Schleife von
 Zeile \ref{alg:arlabeling-neighbour-case2-loop-start} bis Zeile \ref{alg:arlabeling-neighbour-case2-loop-end} wird die
 Liste durchlaufen und alle Werte von $m$ durch den Wert $n$ ersetzt. Falls der Wert $m$ kleiner als $n$ ist
 (Zeile \ref{alg:arlabeling-neighbour-case2-nm-start}--\ref{alg:arlabeling-neighbour-case2-nm-stop}) wird das gleiche
 Verfahren angewendet. Lediglich $m$ und $n$ werden getauscht. Wenn es sich bei $m$ und $n$ um den gleichen Wert
 handet, und somit $m$ und $n$ zur gleichen Region gehören, wird der Wert $m$ in $\mathit{l\_image}$ gespeichert
 (Zeile \ref{alg:arlabeling-neighbour-case2-savem}).

\input{alg/analyse-artplus/arlabeling-neighbour-case2-2}

\autoref{alg:arlabeling-neighbour-case2-2} behandelt den Fall, dass $N_4$ und $N_1$ eine Markierung aufweisen. Das Verfahren entspricht dem Verfahren in \autoref{alg:arlabeling-neighbour-case2-1}.

In \autoref{alg:arlabeling-neighbour-case2-3} ist der Fall beschrieben, dass $N_4$ der einzige Nachbar des
 Vordergrundpixels $(u,v)$ ist. In diesem Fall wird der Wert der Markierung von $N_4$ in $\mathit{l\_image}$
 gespeichert (Zeile \ref{alg:arlabeling-neighbour-case2-3-n4}). Danach wird der Adressabstand berechnet, um die
 Informationen der Regionenmarkierung in $\mathit{work2}$ zu aktualisieren. Zuerst wird in Zeile
 \ref{alg:arlabeling-neighbour-case2-3-incregion} die Anzahl der Vordergrundpixel der Region erhöht. An Position 1 und
 Position 2 von $\mathit{work2}$ werden die Werte von $i$ und $j$ aufaddiert. Falls in Zeile
 \ref{alg:arlabeling-neighbour-case2-3-isismaller} die Position $x$ des ersten Vordergrundpixels der Region größer ist,
 als der aktuelle Wert in $i$, wird die Position in Zeile \ref{alg:arlabeling-neighbour-case2-3-newi} aktualisiert. Zum
 Schluss wird die Position $y$ des letzten Vordergrundpixels der Region durch den aktuellen Wert $j$ ersetzt.

\input{alg/analyse-artplus/arlabeling-neighbour-case2-3}

% paragraph fall_2_ (end)

\paragraph{3. Fall:} % (fold)
\label{par:fall_3_}
Beim dritten Fall wird die Markierung $N_2$ untersucht und wir wissen, dass $N_3$ und $N_4$ keine Markierungen haben
 können. Demnach kann es nur den Nachbarn $N_2$ geben, dessen Markierung an $I(u,v)$ weitergereicht wird. Falls $N_1$
 ebenfalls ein Vordergrundpixel ist, handelt es sich um die gleiche Markierung wie in $N_2$, da beide Vordergrundpixel
 direkt miteinander verbunden sind. Das Verfahren ist in \autoref{alg:arlabeling-neighbour-case3} dargestellt.

\input{alg/analyse-artplus/arlabeling-neighbour-case3}

Für diesen Fall müssen nur die Daten in $\mathit{work2}$ gespeichert werden. Der Wert von $N_2$ wird im Regionenbild
 $\mathit{l\_image}$ gespeichert. Danach wird in Zeile \ref{alg:arlabeling-neighbour-case3-offset} der Adressabstand
 zur Speicherung der Daten in $\mathit{work2}$ berechnet. Danach wird die Anzahl der Vordergrundpixel der Region erhöht
 und $i$ und $j$ auf die bestehenden Werte in $\mathit{work2}$ addiert. Falls die $x$-Koordinate des letzten
 Vordergrundpixels der Region kleiner als der aktuelle Wert $i$ ist, wird die $x$-Koordinate in Zeile
 \ref{alg:arlabeling-neighbour-case3-newi} ersetzt. Zum Schluss wird die $y$-Koordinate des letzten Vordergrundpixels
 der Region mit dem Wert $j$ aktualisiert.

% paragraph fall_3_ (end)

\paragraph{4. Fall:} % (fold)
\label{par:fall_4_}
Der vierte Fall untersucht den letzten, und einzigen, Nachbarn $N_1$ (\autoref{alg:arlabeling-neighbour-case4}). Alle
 anderen Nachbarn sind keine Vordergrundpixel und es besteht keine Kollision. Die Markierung von $N_1$ wird für
 $I(u,v)$ übernommen (Zeile \ref{alg:arlabeling-neighbour-case4-n1}). Ansonsten sind
 \autoref{alg:arlabeling-neighbour-case4} und \autoref{alg:arlabeling-neighbour-case3} identisch.

\input{alg/analyse-artplus/arlabeling-neighbour-case4}

% paragraph fall_4_ (end)

\paragraph{5. Fall:} % (fold)
\label{par:fall_5_}
Im letzten Fall sind alle Nachbarn Hintergrundpixel und $\mathit{l\_image}$ wird eine neue Markierung für $I(u,v)$
 zugewiesen (\autoref{alg:arlabeling-neighbour-case5}).

\input{alg/analyse-artplus/arlabeling-neighbour-case5}

In Zeile \ref{alg:arlabeling-neighbour-case5-incwk_max} wird der aktuelle numerische Markierungswert erhöht. Falls der
 Wert in $\mathit{wk\_max}$ größer als ein festgelegter Wert ist, wird das Verfahren abgebrochen, da zuviele Regionen
 im Bildsignal $I$ vorkommen. Die Markierung wird in Zeile \ref{alg:arlabeling-neighbour-case5-save-uv} in
 $\mathit{l\_image}$ gespeichert. Danach wird die der Wert der Markierung in die Liste der Markierungen $\mathit{work}$
 eingetragen. Der Adressabstand für die Region mit der Markierung $\mathit{wk\_max}$ wird in Zeile
 \ref{alg:arlabeling-neighbour-case5-offset} berechnet. Anschliessend wird die neue Region in $\mathit{work2}$
 gespeichert. Der erste Vordergrundpixel wird in Zeile \ref{alg:arlabeling-neighbour-case5-offset-0} an Position $0$
 von $\mathit{work2}$ gespeichert. Danach werden in Zeile
 \ref{alg:arlabeling-neighbour-case5-offset-1}--\ref{alg:arlabeling-neighbour-case5-offset-1} die Position des ersten
 Vordergrundpixels gespeichert.

% paragraph fall_5_ (end)

Nachdem die Regionemarkierung abgeschlossen ist, enthält $\mathit{work}$ die numerischen Werte der Regionen. In
 $\mathit{work2}$ ist für jede Region die Anzahl der Vordergrundpixel, die summierten $x$- und $y$-Koordinaten aller
 Vordergrundpixel, sowie die $x$- und $y$-Koordinate für den ersten und letzten Vordergrundpixel, hinterlegt. Das
 Regionenbild ist in $\mathit{l\_image}$ gespeichert. Die erfassten Daten müssen nun in Schritt \ref{label-cleaning} von
 \autoref{alg:arlabeling-overview} aufbereitet werden. Zuerst werden mit \autoref{alg:sortlabels} die Werte
 in $\mathit{work}$ sortiert.

Die aufsteigenden Markierungswerte in $\mathit{work}$ sind duch Kollisionen in
 \autoref{alg:arlabeling-neighbour-case2-1} durch kleinere Werte ersetzt worden. Dadurch ist eine Lücke im Interval
 $\left[1,2,3..n\right]$ der numerischen Werte entstanden. Diese Lücken werden durch \autoref{alg:sortlabels}
 entfernt, um wieder ein aufsteigendes Interval zu erhalten.

\input{alg/analyse-artplus/arlabeling-sortlabels}

In Zeile \ref{alg:sortlabels-j} wird $j$ als Variable für die aktuelle Markierung initialisiert. In Zeile
 \ref{alg:sortlabels-address} wird die Adresse der ersten Markierung aus $\mathit{work}$ in $\mathit{wk}$ gespeichert.
 Die Schleife in Zeile \ref{alg:sortlabels-loop-start}--\ref{alg:sortlabels-loop-end} überprüft, ob die numerischen
 Werte ohne Lücken durch Kollisionen gespeichert sind. Dazu wird jeder Eintrag in $\mathit{work}$ mit der Laufvariable
 $i$ verglichen. Falls keine Kollisionen vorliegen, werden die Werte in $\mathit{work}$ immer mit $i$ übereinstimmen,
 da keine Lücken im Intervall vorhanden sind. In Zeile \ref{alg:sortlabels-savelabel} wird dann der Wert aus $j$ an die
 aktuelle Position von $\mathit{work}$ geschrieben und $j$ danach inkrementiert. Bei einer Kollision stimmt der Wert in
 $\mathit{work}$ nicht mit $i$ überein
 (Zeile \ref{alg:sortlabels-collision-start}--\ref{alg:sortlabels-collision-end}). In diesem Fall wird der Wert an der
 aktuellen Position von $\mathit{work}$ ausgelesen und dekrementiert. Dieser Wert wird als Index verwendet um den Wert
 des zuletzt zugewiesenen Markierungswert an die aktuelle Position von $\mathit{work}$ zu schreiben. Da die Variable
 $j$ in diesem Fall nicht inkrementiert wird, enthält sie den nächsten Wert des Markierungsintervals. In Zeile
 \ref{alg:sortlabels-inci} wird die Laufvariable $i$ um $1$ erhöht und in Zeile \ref{alg:sortlabels-incwk} die Adresse
 von $\mathit{work}$ inkrementiert. Das Beispiel in \autoref{fig:} illustriert das Verfahren.

% subsection fiducial_detection (end)

\subsection{Rectangle Fitting} % (fold)
\label{sec:rectangle_fitting}

% subsection rectangle_fitting (end)

% section artoolkitplus (end)

