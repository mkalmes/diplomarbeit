\section{Verfahren nach Hirzer} % (fold)
\label{sec:hirzer}

\subsection{Datenstrukturen} % (fold)
\label{sub:datenstrukturen}

Die Datenstruktur eines \gls{edgels} besteht aus der $x$- und $y$-Koordinate und der Orientierung
 (Vgl. \autoref{alg:datastructure-edgel}). Lese- und Schreibzugriffe auf die Elemente eines \gls{edgels} sind konstant.

\input{alg/datastructure-edgel}

Der Vergleich, ob \gls{edgels} kompatibel sind, wird mit \autoref{alg:compatibleedgel} bewerkstelligt. Als Parameter
 werden zwei zu vergleichende \gls{edgels} $e_1$ und $e_2$ übergeben. In Zeile~$6$ und $13$ wird sichergestellt, dass
 $e_1.o$ und $e_2.o$ innerhalb von $67.5^\circ$\footcite[Vgl.][S.~417]{clarke96} liegen und damit kompatibel wären.
 Dies wird durch

\begin{equation}
	d = 2 \pi \left( \frac{ \frac{67.5}{2} }{360} \right) = 0.589
\end{equation}

überprüft. Es muss sichergestellt werden, dass die Orientierung in Bogenmaß erfolgt.

\input{alg/compatibleedgel}

Der Edgelspeicher in \autoref{alg:datastructure-edgelpool} verwendet ein Array von \gls{edgels}
 (Vgl. \autoref{alg:datastructure-edgel}) mit fester Größe $N$ und einer Zählvariable um die nächste freie Position im
 Array zu markieren. Der Speicherpool aus \autoref{alg:datastructure-poolimplementation} ist ein Array vom Typ des
 Edgelspeichers mit der Größe $S$, dessen Adresse im Pointer $\mathit{pool}$ gespeichert wird.

\input{alg/datastructure-edgelpool}

\autoref{alg:edgelpool-getmemorypools} basiert auf einem einfachen Stack Allocator von
 \citeauthor{kr}\footcite[Vgl.][S.~100--104]{kr}. Die Variable $n$ gibt die Anzahl der angeforderten Pools an. In Zeile
 \ref{alg:edgelpool-getmemorypools-checkpoolsize} wird überprüft, ob genügend Pools zur Verfügung stehen und liefert im
 Erfolgsfall die Adresse zu einem Speicher (\autoref{alg:datastructure-edgelpool}) zurück. Falls kein Pool mehr zur
 Verfügung steht, wird $\mathit{NULL}$ zurückgegeben. \autoref{alg:edgelpool-getmemorypool} vereinfacht die Anforderung
 eines Pools, da in den meisten Fällen nur ein Pool benötigt wird. Bei einem Aufruf kann somit auf einen Parameter
 verzichetet werden. Sowohl \autoref{alg:edgelpool-getmemorypools} als auch \autoref{alg:edgelpool-getmemorypool} haben
 eine konstante Laufzeit.

\input{alg/edgelpool-getmemorypools}

\input{alg/edgelpool-getmemorypool}

Um \gls{edgels} in einem Pool zu speichern, verwende ich \autoref{alg:edgelpool-addedgel}. Der Algorithmus benötigt
 einen Pointer $p$ auf einen Pool und einen \gls{edgels} $e$. In Zeile
 \ref{alg:edgelpool-addedgel-validpointer-start}--\ref{alg:edgelpool-addedgel-validpointer-end} wird geprüft, ob der
 Pointer auf eine Adresse verweist. Falls $p$ null ist, wird der Algorithmus verlassen. In Zeile
 \ref{alg:edgelpool-addedgel-checkspace-start}--\ref{alg:edgelpool-addedgel-checkspace-end} wird geprüft, ob im Array
 genügend Platz für einen weiteren Eintrag vorhanden ist. Die Größe von $N$ Einträgen richtet sich nach der in \autoref{alg:datastructure-edgelpool} festgelegten Arraygröße $N$. Wenn genügend Platz vorhanden ist, wird in Zeile
 \ref{alg:edgelpool-addedgel-add-start}--\ref{alg:edgelpool-addedgel-add-end} der \gls{edgels} $e$ an die freie
 Position $c$ geschrieben. Danach wird $\mathit{count}$ inkrementiert. Das hinzufügen eines \gls{edgels} ist konstant.

\input{alg/edgelpool-addedgel}

\gls{edgels} werden mittels \autoref{alg:edgelpool-getedgel} gelesen. Dazu wird der Pointer $p$ auf den Pool und der
 Index $i$ übergeben. In Zeile
 \ref{alg:edgelpool-getedgel-validpointer-start}--\ref{alg:edgelpool-getedgel-validpointer-end} wird geprüft, ob es
 sich um einen gesetzten Pointer handelt. Anschliessend wird in Zeile
 \ref{alg:edgelpool-getedgel-validrange-start}--\ref{alg:edgelpool-getedgel-validrange-end} geprüft, ob der Index $i$
 innerhalb des gespeicherten Bereichs der \gls{edgels} liegt. Danach wird in Zeile
 \ref{alg:edgelpool-getedgel-returnedgel} der Wert des \gls{edgels} an Position $i$ zurückgegeben. Der Zugriff auf
 einen \gls{edgels} ist konstant.

\input{alg/edgelpool-getedgel}

Damit \gls{edgels} aus dem Array entfernt werden können, wird \autoref{alg:edgelpool-removeedgel} verwendet. Es wird der
 Pool-Pointer $p$ und die Position $i$ des zu löschenden \gls{edgels} übergeben. Nach der Überprüfung des Pointers $p$
 in Zeile \ref{alg:edgelpool-removeedgel-validpointer-start}--\ref{alg:edgelpool-removeedgel-validpointer-end} und der
 Überprüfung des zulässigen Bereichs in Zeile
 \ref{alg:edgelpool-removeedgel-validrange-start}--\ref{alg:edgelpool-removeedgel-validrange-end}, gibt es zwei zu
 behandelnde Fälle um einen \gls{edgels} zu löschen.

\input{alg/edgelpool-removeedgel}

Der Edgel liegt
\begin{enumerate}
	\item nicht am Ende des Arrays oder \label{removeedgel-worst}
	\item liegt am Ende des Arrays. \label{removeedgel-best}
\end{enumerate}

Bei \ref{removeedgel-best} muss lediglich $\mathit{count}$ dekrementiert werden um auf den vorigen Wert zu verweisen
 (Vgl. \autoref{fig:decrementcounter}). Das dekrementieren der Zählvaribale $p(\mathit{count})$ ist eine Zuweisung in
 konstanter Zeit. % TODO: Grafik -> [1][2]..[n-1][n|c] wird zu [1][2]..[n-1|c][n]

Bei \autoref{removeedgel-worst} wird das Array an der Position $i$ geteilt und der Wertebereich von $[i+1 \dotsc i-n]$
 wird an die Position $i$ verschoben (Vgl. \autoref{fig:memmove}). % TODO: Grafik [1][2]..[i-1][i][i+1]..[i-n]
In Zeile \autoref{alg:edgelpool-removeedgel-memmove} gibt die Funktion \textproc{sizeof}($e$) die Speichergröße eines
 \gls{edgels} an, welche zum verschieben der Daten notwendig ist. Mit $c - (i + 1)$ wird die Anzahl der zu
 verschiebenden Einträge ermittelt. Im worst-case werden $N-1$ Einträge an Position $0$ des Arrays verschoben.

Um die Laufzeit der Funktion \textproc{memmove} zu bestimmen, wurde ein Testprogramm geschrieben, dass die Zeit misst,
 die benötigt wird, um Einträge zu verschieben. Anhand der Daten wurde mittels einer Regressionsanalyse untersucht, ob
 die gemessenen Daten einen linearen Zusammenhang aufweisen. Die erfassten $2000$ Datenpunkte wurde nach dem Vorbild von
 \textproc{time} % TODO: Referenz auf den Katalog für /usr/bin/time und man-page
ermittelt um Real-, User- und Sys-Zeit zu bestimmen. Aus User- und Sys-Zeit wurde die CPU-Zeit bestimmt, die zur
 Analyse benutzt wurde. Die Kovarianz für $X = \mathit{BYTES}$ und $Y = \mathit{CPU}$ beträgt $r = 0.9937538$ und
 $r^2 = 0.9875$. An dieser Stelle sei darauf hingewiesen, dass die Kovarianz für $X = \mathit{BYTES}$ und
 $Y = \mathit{REAL}$ mit $r = 0.9981969$ zwar größer ist, aber nicht die tatsächlichen Operationen des Testprogramms
 untersucht. Aus diesem Grund wurde $Y = \mathit{CPU}$ untersucht. Der Interzept beträgt $\beta_0 = -71.89\e{-06}$
 (Abweichung von $71.98\e{-06}$) und die Steigung $\beta_1 = 4.410\e{-09}$ (Abweichung von $11.08\e{-12}$), sodass

\begin{subequations}
\begin{multline}
	y =\\ \beta_0 + \beta_1n
\end{multline}
\begin{multline}
	y =\\ -71.89\e{-06} + 4.410\e{-09}n
\end{multline}
\end{subequations} % TODO: Sauber formatieren

Daraus ergibt sich eine Laufzeit von $\Theta(n)$. In \autoref{fig:regression-memmove} ist der Plot der Daten angegeben.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=.8\textwidth]{resources/Regression-memmove.png}
	\caption{Regressionsanalyse von $2000$ Datenpunkten.}
	\label{fig:regression-memmove}
\end{figure}

Um einen Pool für einen neuen Durchlauf zu löschen, kommt \autoref{alg:edgelpool-resetmemorypool} zum Einsatz. Als
 Parameter wird der Pointer $p$ übergeben und in Zeile
 \ref{alg:edgelpool-resetmemorypool-validpointer-start}--\ref{alg:edgelpool-resetmemorypool-validpointer-end}
 überprüft. Um alle Daten als gelöscht zu makieren, wird lediglich die Zählvariable in Zeile
 \ref{alg:edgelpool-resetmemorypool-reset} auf $0$ gesetzt. Die Zuweisung erfolgt in konstanter Zeit.

\input{alg/edgelpool-resetmemorypool}

Wenn ein Speicherpool nicht mehr benötigt wird, kann er mit \autoref{alg:edgelpool-freememorypool} freigegeben werden.
 Der Pointer $p$ wird in Zeile
 \ref{alg:edgelpool-freememorypool-validpointer-start}--\ref{alg:edgelpool-freememorypool-validpointer-end} überprüft.
 Zeile \ref{alg:edgelpool-freememorypool-resetmemory} werden die Daten des Pools gelöscht
 (Vgl. \autoref{alg:edgelpool-resetmemorypool}). Im Anschluss wird in Zeile
 \ref{alg:edgelpool-freememorypool-checkpointer} überprüft, ob $p$ zu dem Array $\mathit{data}$ gehört und nicht größer
 als die definierte Speichergröße ist. Wenn der Test positiv ausfällt, wird der Pointer $p$ zur weiteren Verwendung in
 $\mathit{pool}$ gespeichert. Das freigeben eines Pools erfolgt in konstanter Zeit.

\input{alg/edgelpool-freememorypool}

Die Anzahl der \gls{edgels} in einem Pool werden durch \autoref{alg:edgelpool-count} ermittelt. Als Parameter wird
 Pointer $p$ übergeben und in Zeile
 \ref{alg:edgelpool-count-validpointer-start}--\ref{alg:edgelpool-count-validpointer-end} überprüft. Die Anzahl der
 Einträge wird in Zeile \ref{alg:edgelpool-count-counter} über die Zählvariable $p(\mathit{count})$ ermittelt. Der
 Zugriff auf die Variable, und somit die Laufzeit des Algorithmus, erfolgt in konstanter Zeit.

\input{alg/edgelpool-count}

Die Datenstruktur eines Liniensegments und die Methoden zum hinzufügen, löschen und freigeben des Speichers sind nach
 dem Vorbild des Edgelspeichers aufgebaut. Die Datenstruktur eines Liniensegments ist in
 \autoref{alg:datastructure-line} definiert. Eine Linie besteht aus den \gls{edgels} $s$ und $e$, die den Start- und
 End-Punkt der Linie darstellen. Variable $c$ speichert die Anzahl der unterstützenden Edgels der Linie. Die Lese- und
 Schreibzugriffe auf die Datenstruktur ist konstant.

\input{alg/datastructure-line}

Die Datenstruktur eines Speicherpools für Linien in \autoref{alg:datastructure-linepool} besteht aus einem Array
 $\mathit{data}$ mit der festen Größe $N$ und einer Zählvariablen $\mathit{count}$.

\input{alg/datastructure-linepool}

Der Speicherpool für Linien in \autoref{alg:datastructure-linepool-implementation} besteht wiederum aus einem Array
 $\mathit{data}$ mit der Anzahl $S$ der zur Verfügung stehenden Speicherpools. Der Pointer von $\mathit{data}$ wird in
 der Variablen $\mathit{pool}$ gespeichert. Der Zugriff auf die Datenstruktur erfolgt in konstanter Zeit.

Mehrere Speicherpools können mit \autoref{alg:linepool-getmemorypools} geholt werden und mit
 \autoref{alg:linepool-getmemorypool} wird ein Speicherpool angefordert. Der Aufbau entspricht dem des Speicherpool für
 \gls{edgels} (Vgl. \autoref{alg:edgelpool-getmemorypools} und \autoref{alg:edgelpool-getmemorypool}). Der Zugriff
 erfolgt in konstanter Zeit.

\input{alg/linepool-getmemorypools}

\input{alg/linepool-getmemorypool}

Um eine Linie dem Speicherpool hinzuzufügen, wird \autoref{alg:linepool-addline} verwendet. Es wird ein Pointer $p$ auf
 den Speicherpool, sowie eine Linie $l$ übergeben. Wenn es sich um einen gültigen Pointer $p$ handelt und genügend
 freier Speicherplatz für eine weitere Linie vorhanden ist, wird in Zeile
 \ref{alg:linepool-addline-add-start}--\ref{alg:linepool-addline-add-end} die Linie hinzugefügt und die Zählvariable
 inkrementiert. Das hinzfügen einer Linie ist konstant.

\input{alg/linepool-addline}

Zum auslesen einer Linie aus dem Speicherpool, wird \autoref{alg:linepool-getline} verwendet. Als Parameter werden ein
 Pointer $p$ und ein Index $i$ übergeben. Der Index gibt an, welche Linie aus dem Pool ausgelesen werden soll. In Zeile
 \ref{alg:linepool-getline-validrange-start} wird geprüft, ob der Index sich innerhalb der Grenzen der gespeicherten
 Linien befindet. Wenn dies der Fall ist, wird in Zeile \ref{alg:linepool-getline-returnline} die Linie in konstanter
 Zeit zurückgegeben.

\input{alg/linepool-getline}

Mit \autoref{alg:linepool-resetmemorypool} werden die Einträge im Speicherpool gelöscht. Dazu wird der Pointer $p$ auf
 den Speicherpool übergeben und in Zeile
 \ref{alg:linepool-resetmemorypool-validpointer-start}--\ref{alg:linepool-resetmemorypool-validpointer-end} überprüft.
 Wenn es sich um einen gültigen Pointer handelt, wird die Zählvariable auf $0$ gesetzt. Da es sich um einen direkten
 Zugriff handelt, erfolgt das löschen in konstanter Zeit.

\input{alg/linepool-resetmemorypool}

Durch \autoref{alg:linepool-freememorypool} kann ein Speicherpool wieder freigegeben werden. Dazu wird der Pointer $p$
 auf Gültigkeit geprüft. Danach wird der Speicher durch \textproc{resetmemorypool}
 (\autoref{alg:linepool-resetmemorypool}) gelöscht. In Zeile \ref{alg:linepool-freememorypool-checkpointer} wird
 überprüft, ob der Pointer $p$ zu dem entsprechenden Pool gehört um danach die Adresse in Zeile
 \ref{alg:linepool-freememorypool-savepointer} im Speicherpool $\mathit{pool}$ zu speichern. Auch hier erfolgt das
 freigeben des Speichers wieder in konstanter Zeit.

\input{alg/linepool-freememorypool}

Die Anzahl der Einträge in einem Pool werden durch \autoref{alg:linepool-count} bestimmt, indem die Zählvariable
 $\mathit{count}$ zurückgegeben wird. Der Zugriff auf die Variable erfolgt in konstanter Zeit.

\input{alg/linepool-count}

Im Verfahren nach \citeauthor{clarke96} gibt es keinen Grund Linien aus dem Speicherpool zu löschen. Darum kann auf
 einen Algorithmus wie \autoref{alg:edgelpool-removeedgel} bei \gls{edgels} verzichtet werden.

Alle Operationen für Linien erfolgen somit in konstanter Zeit $T(n) = \Theta(1)$.

% subsection datenstrukturen (end)

\subsection{Linienerkennung nach \citeauthor{clarke96}} % (fold)
\label{sub:linienerkennung_nach_clarke96}

Der Algorithmus von \citeauthor{clarke96} ist in \autoref{alg:linedetection-analyze} aufgeführt. Zuerst wird die Breite
 $w$ und Höhe $h$ des Signals $I_m$ festgehalten. Die doppelte For-Schleife in Zeile
 \ref{alg:linedetection-analyze-start} bis \ref{alg:linedetection-analyze-end} unterteilt das Signal in Regionen der
 Größe $40 \times 40$ \gls{pixel}, indem die Koordinate der oberen linken Ecke berechnet wird.

\input{alg/linedetection-analyze}

In \citeauthor{clarke96} ist keine Angabe zu den Abmessungen der untersuchten Signale angegeben. Auch der Grund warum
 eine Region $40 \times 40$ \gls{pixel} gross sein muss, fehlt. Zur Analyse der Videosignale verwendeten
 \citeauthor{clarke96} einen Framegrabber 2000 der eine Auflösung von 640x480px schafft. Betrachtet man

$640 mod 40 = 0$ und $480 mod 40 = 0$

ist ersichtlich, dass die Größe der Region in der Aufteilung des Bildsignals in Zusammenhang steht.

Der \autoref{alg:linedetection-analyze} ist der zentrale Algorithmus von \citeauthor{clarke96}. Der Algorithmus
 ist verantwortlich für die Unterteilung des Bildsignals in Regionen von jeweils $40 \times 40$ \gls{pixel}
 (Vgl. Zeile~\ref{alg:linedetection-analyze-start}--\ref{alg:linedetection-analyze-end}). Die Kosten des Algorithmus
 sind in \autoref{eq:linedetection-analyze1} aufgeführt. Um die Gleichung zu vereinfachen führe ich in
 \autoref{eq:linedetection-analyze2} $n = \tfrac{h}{40}$ und $k = \tfrac{w}{40}$ ein. Sowohl bei worst-case als auch
 bei best-case werden die Summen immer vollständig durchlaufen. Damit kann die Gleichung zu
 \autoref{eq:linedetection-analyze3} vereinfacht werden, was eine Laufzeit von $\Theta(nk)$ ergibt.

\begin{subequations}
\label{eq:linedetection-analyze}
\begin{multline}
	T(I) = c_1
	+ c_2
	+ c_3 \left(\frac{h}{40} + 1\right)
	+ c_4 \sum \limits_{y = 0}^{\frac{h}{40}} t_y \left(\frac{w}{40} + 1 \right)
	+ c_5 \sum \limits_{y = 0}^{\frac{h}{40}} \sum \limits_{x = 0}^{\frac{w}{40}} t_y t_x\\
	+ c_6 \sum \limits_{y = 0}^{\frac{h}{40}} \sum \limits_{x = 0}^{\frac{w}{40}} t_y t_x
	+ c_7 \sum \limits_{y = 0}^{\frac{h}{40}} \sum \limits_{x = 0}^{\frac{w}{40}} t_y t_x
	+ c_9 \sum \limits_{y = 0}^{\frac{h}{40}} t_y
	\label{eq:linedetection-analyze1}
\end{multline}
\begin{multline}
	T(I) = c_1
	+ c_2
	+ c_3 \left(n + 1\right)
	+ c_4 \sum \limits_{y = 0}^{n} t_y \left(k + 1 \right)
	+ c_5 \sum \limits_{y = 0}^{n} \sum \limits_{x = 0}^{k} t_y t_x\\
	+ c_6 \sum \limits_{y = 0}^{n} \sum \limits_{x = 0}^{k} t_y t_x
	+ c_7 \sum \limits_{y = 0}^{n} \sum \limits_{x = 0}^{k} t_y t_x
	+ c_9 \sum \limits_{y = 0}^{n} t_y
	\label{eq:linedetection-analyze2}
\end{multline}
\begin{multline}
	T(I) =
	c_1
	+ c_2
	+ c_3 \left(n + 1\right)
	+ c_4 \left[n \left(k + 1 \right)\right]
	+ c_5 n k
	+ c_6 n k
	+ c_7 n k
	+ c_9 n\\
	= c_1 + c_2 + c_3 + \left(c_3 + c_4 + c_9\right) n + \left(c_4 + c_5 + c_6 + c_7\right) n k
	\label{eq:linedetection-analyze3}
\end{multline}
\end{subequations}

Das Verfahren zur Bestimmung der Edgels (\autoref{alg:findedgels-horizontal}) benötigt das monochrome Bildsignal $I_m$,
 sowie die Position der oberen linken Ecke der Region, die durch oben $t$ und links $l$ definiert ist. Die Breite und
 Höhe der Region ist durch $\mathit{rw}$ und $\mathit{rh}$ angegeben. Die Abmessung des Bildsignals werden als $w$ und
 $h$ bezeichnet. Der Pointer $E$ wird zur Speicherung der gefundenen \gls{edgels} verwendet.

\input{alg/findedgels}

Zeile~\ref{alg:findedgels-horizontal-scanlinestart}--\ref{alg:findedgels-horizontal-scanlineend} ist für den Aufbau der
 horizontalen Scanlines verantwortlich. Die Überprüfung sorgt dafür, dass die Scanlines bis zum Ende der Region im
 Abstand von $5$ Pixeln untersucht werden. Nach der Initialisierung der Variablen wird in der Schleife von
 Zeile~\ref{alg:findedgels-horizontal-loopstart}--\ref{alg:findedgels-horizontal-loopend} jeder Pixel auf der Scanline
 untersucht. Zuerst wird in Zeile~\ref{alg:findedgels-horizontal-convolute} die Faltung mit einem Gauß-Kernel
 vorgenommen (Vgl. \autoref{alg:derivativeofgauss-horizontal}, S.~\pageref{alg:derivativeofgauss-horizontal}). Der Test
 in Zeile~\ref{alg:findedgels-horizontal-foundedgel} überprüft anschließend das Ergebnis der Faltung. Wenn der
 Schwellwert nicht überschritten wird, gibt es keinen genügend großen Anstieg des Gradienten und das Ergbnis wird auf
 $0$ gesetzt. Wird der Schwellwert überschritten, handelt es sich um einen Edgel und das Ergbnis wird in den
 Bedingungen von Zeile~\ref{alg:findedgels-horizontal-maxima} weiter untersucht, ob es sich um ein lokales Maximum
 handelt. Ein lokales Maximum bedeutet, dass ein Edgel einen größeren Gradienten besitzt als seine beiden Nachbarn.

Die Bedingung in Zeile~\ref{alg:findedgels-horizontal-maxima} wird bei der ersten Überprüfung immer fehlschlagen.
 Dadurch wird sichergestellt, dass kein Maximum an den Rändern existiert, da hier nicht genügend Nachbarn vorhanden sind
 um eine verlässliche Aussage zu treffen. Zeile~\ref{alg:findedgels-horizontal-copy-prev1} und
 Zeile~\ref{alg:findedgels-horizontal-copy-edgel} kopieren die Werte für den nächsten Durchlauf. Durch das kopieren der
 Werte werden die Nachbarn für den nächsten Durchlauf um eine Position weiterverschoben. Nur bei einem lokalen Maximum
 wird die Position des Edgels gespeichert, und seine Orientierung (Vlg. \autoref{alg:sobel},
 S.~\pageref{alg:sobel}) berechnet. Der Edgel wird in (einer Liste|einem Memorypool) zu weiteren Verarbeitung
 gespeichert.

Sind alle Pixel auf einer Scanline untersucht, wird in Zeile~\ref{alg:findedgels-horizontal-increment} die nächste
 Scanline ausgewählt. Das Verfahren wird solange wiederholt, bis alle Scanlines innerhalb der Region untersucht wurden.

\autoref{alg:findedgels-vertical} untersucht die vertikalen Scanlines in Zeile
 \ref{alg:findedgels-vertical-scanlinestart}--\ref{alg:findedgels-vertical-scanlineend} analog zu
 \autoref{alg:findedgels-horizontal} Zeile
 \ref{alg:findedgels-horizontal-scanlinestart}--\ref{alg:findedgels-horizontal-scanlineend}.

\autoref{alg:derivativeofgauss-horizontal} und \autoref{alg:derivativeofgauss-vertical} berechnen den Gradienten durch Faltung mit dem Gauß-Kernel
$\left( \begin{smallmatrix}
-3& -5& 0& 5& 3
\end{smallmatrix} \right)$
 auf der horizontalen und vertikalen Scanline. Als Parameter benötigt der Algorithmus den Pointer des monochromen
 Bildsignals $I_m$, die Position des Pixels ($x$ und $y$), sowie die Breite $w$ und Höhe $h$ von $I_m$. In Zeile
 \ref{alg:derivativeofgauss-horizontal-readstart}--\ref{alg:derivativeofgauss-horizontal-readend} werden durch die
 Funktion \textproc{getpixel} (Vgl. \autoref{alg:getpixel}, S. \pageref{alg:getpixel}) die benötigten Pixelwerte
 ausgelesen und den Variablen zugewiesen. Im Anschluss werden die Werte mit dem Gauß-Kernel
$\left( \begin{smallmatrix}
-3& -5& 0& 5& 3
\end{smallmatrix} \right)$
berechnet um den Gradienten zu bestimmen.

\input{alg/derivativeofgauss.tex}

Durch die Multiplikation mit $\tfrac{1}{16}$ wird sichergestellt, dass der maximale Wert

\begin{equation}
	\frac{1}{16}
	\cdot
	\begin{pmatrix}
		-3& -5& 0& 5& 3
	\end{pmatrix}
	\cdot
	\begin{pmatrix}
		0& 0& 0& 255& 255
	\end{pmatrix}
	= 127.5
\end{equation}

und der minimale Wert

\begin{equation}
	\frac{1}{16}
	\cdot
	\begin{pmatrix}
		-3& -5& 0& 5& 3
	\end{pmatrix}
	\cdot
	\begin{pmatrix}
		255& 255& 0& 0& 0
	\end{pmatrix}
	= -127.5
\end{equation}

für ein monochromes Bild eingehalten werden.

Bei genauer Betrachtung von \autoref{alg:derivativeofgauss-horizontal} und \autoref{alg:derivativeofgauss-vertical}
 fällt auf, dass der Wert $p_3$ in der Berechnung nicht mit einfliesst. Dies ist darauf zurückzuführen, dass bei der
 Multiplikation des Gauß-Kernels an der dritten Stelle des Filter mit $0$ definiert ist. Eine Multiplikation mit $0$
 ergibt immer $0$ und kann somit vernachlässigt werden. Die Laufzeit von \autoref{alg:derivativeofgauss-horizontal} und
 \autoref{alg:derivativeofgauss-vertical} ist konstant.

In \autoref{alg:sobel} wird, wie in \autoref{alg:derivativeofgauss-horizontal}, mittels Faltung die Orientierung eines
 \gls{edgels} bestimmt. Als Eingabeparameter wird das monochrome Bildsignal $I_m$, dessen Breite $w$ und Höhe $h$,
 sowie die Position des \gls{edgels} ($x,y$) benötigt.

\input{alg/sobel}

In Zeile \ref{alg:sobel-readstart}--\ref{alg:sobel-readend} werden die Pixelwerte ausgelesen und den Variablen
 zugewiesen. In Zeile \ref{alg:sobel-convolutestart}--\ref{alg:sobel-convoluteend} erfolgt die Faltung mit dem
 Sobel-Operator\footcite[Vgl.][S.~120--123]{burger05}, dessen Filter

\begin{subequations}
\begin{align}
	H_x =&
	\begin{pmatrix}
		1& 0& -1\\
		2& 0& -2\\
		1& 0& -1
	\end{pmatrix}
\end{align}
\begin{align}
	H_y =&
	\begin{pmatrix}
		1& 2& 1\\
		0& 0& 0\\
		-1& -2& -1
	\end{pmatrix}
\end{align}
\end{subequations}

den Gradienten $G_x$ und $G_y$ bestimmen. Wie in \autoref{alg:derivativeofgauss-horizontal} werden Multiplikationen von
 $0$-Werten des Filters vernachlässigt. Mit

\begin{equation}
	\label{eq:orientation}
	\Phi(x,y) = \arctan{\left(\tfrac{G_y}{G_x}\right)}
\end{equation}

wird die Orientierung in Zeile \autoref{alg:sobel-arctan} berechnet. Die Orientierung unterscheidet sich um $180^\circ$
 wenn anstatt von Weiß nach Schwarz ein verlauf von Schwarz nach Weiß erfolgt. Das Ergebnis liegt im Bereich
 $-\pi < v \leq \pi$. $\arctan$ in \autoref{eq:orientation} kann in C durch \textproc{atan2} zur Berechnung verwendet
 werden. Die Laufzeit von \autoref{alg:sobel} ist konstant.

\input{alg/findlinesegments}

% subsection linienerkennung_nach_clarke96 (end)

% section hirzer (end)
