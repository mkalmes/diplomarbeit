\citeauthor{clarke96} verwenden in ihrem Verfahren ein monochromes Bildsignal $I_m$\footcite[Vgl.][S.~417]{clarke96}.
 Die Konvertierung des Bildsignals $I$ von YCbCr in $I_m$ erfolgt durch \autoref{alg:convertmonochrome}. Wie in
 \autoref{sub:farbräume} beschrieben, besteht ein YCbCr Signal aus einem Luminanz Kanal $Y$ und den Chroma Abweichungen
 $Cb$ und $Cr$. Um ein monochromes Signal $I_m$ zu erstellen, muss der Luminanz Kanal ausgelesen und in einen Puffer
 kopiert werden.
\input{alg/analyse-hirzer/convertmonochrome}
Der Algorithmus verwendet als Parameter das Bildsignal $I$ und einen Zeiger $I_m$ auf einen Puffer für das monochrome
 Signal. Der Monochrompuffer $I_m$ ist ein Array mit fester Größe, das beim initialisieren einmalig angelegt wird und
 danach wiederverwendet werden kann. In Zeile~\ref{alg:convertmonochrome-baseaddress} wird die Adresse des
 Luminanz-Kanals $Y$ ausgelesen. Die Funktionen \textproc{width} und \textproc{height} liefern die Breite und Höhe des
 Signals in Pixeln, mit denen die Länge der Daten berechnet wird. Anschließend werden die Daten in den Puffer kopiert.
 Die Konvertierung des Bildsignals ist Verarbeitungsschritt der vor dem Verfahren von \citeauthor{clarke96} durchgeführt
 wird und wird nur der Vollständigkeit erwähnt.

Um auf \gls{pixel} zugreifen zu können, wird \autoref{alg:getpixel} verwendet.
\input{alg/analyse-hirzer/getpixel}
Es wird der Puffer $I_m$ als Zeiger übergeben und die Position $x$ und $y$ des gewünschten \gls{pixel}. $w$ und $h$
 entsprechen der Breite und Höhe von $I_m$. Zeile~\ref{alg:getpixel-startcheck} bis Zeile~\ref{alg:getpixel-stopcheck}
 sorgen dafür, dass keine Werte außerhalb des Puffers gelesen werden können. Dies ist für die Randbehandlung bei
 Faltungsoperationen (Vgl. \autoref{sub:filter}) wichtig und wiederholt den \gls{pixel}.Die Laufzeit von
 \autoref{alg:getpixel} ist konstant und somit $T(n)=\Theta(1)$.

Der Algorithmus von \citeauthor{clarke96} ist in \autoref{alg:linedetection-clarke} aufgeführt und benötigt das
 monochrome Bildsignal $I_m$.
\input{alg/analyse-hirzer/linedetection-clarke}
In der doppelten Schleife in Zeile \ref{alg:linedetection-clarke-start} bis \ref{alg:linedetection-clarke-end} wird
 $I_m$ in Regionen der Größe $40 \times 40$ \gls{pixel} unterteilt. Die globalen Variablen $\mathit{imageWidth}$ und
 $\mathit{imageHeight}$ enthalten die Breite und Höhe des Bildsignals $I_m$. Die Regionengröße von $40$ \gls{pixel} ist
 in der globalen Variable $\mathit{regionSize}$ gespeichert. In \citeauthor{clarke96}\footcite{clarke96} sind keine
 Hintergrundinformationen zu der Größe einer Region angegeben. Betrachtet man $640 \bmod 40 = 0$ und $480 \bmod 40 = 0$
 ist ersichtlich, dass die Größe der Region und der Aufteilung des Bildsignals in Zusammenhang steht. In Zeile
 \ref{alg:linedetection-clarke-call-start}--\ref{alg:linedetection-clarke-call-end} werden zuerst \glspl{edgel}
 ermittelt, um im Anschluss daraus Liniensegmente zu erstellen. Wenn für eine Region Liniensegmente erstellt und
 gespeichert wurden, wird der Speicherblock der \gls{edgel} und Liniensegmente in Zeile
 \ref{alg:linedetection-clarke-reset-start}--\ref{alg:linedetection-clarke-reset-end} gelöscht.

% \begin{subequations}
% \begin{align}
% \label{eq:linedetection-analyze1}
% T(I)& =
% c_1
% + c_2
% + c_3 \left(\frac{h}{40} + 1\right)
% + c_4 \sum \limits_{y = 0}^{\frac{h}{40}} t_y \left(\frac{w}{40} + 1 \right)
% + c_5 \sum \limits_{y = 0}^{\frac{h}{40}} \sum \limits_{x = 0}^{\frac{w}{40}} t_y t_x\\
% & \quad + c_6 \sum \limits_{y = 0}^{\frac{h}{40}} \sum \limits_{x = 0}^{\frac{w}{40}} t_y t_x
% + c_7 \sum \limits_{y = 0}^{\frac{h}{40}} \sum \limits_{x = 0}^{\frac{w}{40}} t_y t_x
% + c_9 \sum \limits_{y = 0}^{\frac{h}{40}} t_y \nonumber \\
% \label{eq:linedetection-analyze2}
% T(I)& =
% c_1
% + c_2
% + c_3 \left(n + 1\right)
% + c_4 \sum \limits_{y = 0}^{n} t_y \left(k + 1 \right)
% + c_5 \sum \limits_{y = 0}^{n} \sum \limits_{x = 0}^{k} t_y t_x\\
% & \quad + c_6 \sum \limits_{y = 0}^{n} \sum \limits_{x = 0}^{k} t_y t_x
% + c_7 \sum \limits_{y = 0}^{n} \sum \limits_{x = 0}^{k} t_y t_x
% + c_9 \sum \limits_{y = 0}^{n} t_y \nonumber \\
% \label{eq:linedetection-analyze3}
% T(I)& =
% c_1
% + c_2
% + c_3 \left(n + 1\right)
% + c_4 \left[n \left(k + 1 \right)\right]
% + c_5 n k
% + c_6 n k
% + c_7 n k
% + c_9 n\\
% \label{eq:linedetection-analyze4}
% T(I)& = c_1 + c_2 + c_3 + \left(c_3 + c_4 + c_9\right) n + \left(c_4 + c_5 + c_6 + c_7\right) n k\\
% \label{eq:linedetection-analyze5}
% T(I)& = \Theta(nk)
% \end{align}
% \end{subequations}

Das Verfahren zur Bestimmung der Edgels (\autoref{alg:findedgels-horizontal} und \autoref{alg:findedgels-vertical})
 benötigt das monochrome Bildsignal $I_m$, sowie die Position der oberen linken Ecke der Region, die durch oben $t$ und
 links $l$ definiert ist.
\input{alg/analyse-hirzer/findedgelsclarke1}
Der Zeiger $E$ wird zur Speicherung der gefundenen \glspl{edgel} verwendet. Zeile
 \ref{alg:findedgels-horizontal-scanlinestart}--\ref{alg:findedgels-horizontal-scanlineend} ist für den Aufbau der
 horizontalen Scanlines verantwortlich. Die Überprüfung sorgt dafür, dass die Scanlines bis zum Ende der Region im
 Abstand von $5$ Pixeln untersucht werden. Nach der Initialisierung der Variablen wird in der Schleife von
 Zeile~\ref{alg:findedgels-horizontal-loopstart}--\ref{alg:findedgels-horizontal-loopend} jeder Pixel auf der Scanline
 untersucht. Zuerst wird in Zeile \ref{alg:findedgels-horizontal-convolute} die Faltung mit einem Gauß-Kernel
 vorgenommen (Vgl. \autoref{alg:convolutekernel-horizontal}, S. \pageref{alg:convolutekernel-horizontal}). Der Test
 in Zeile \ref{alg:findedgels-horizontal-foundedgel} überprüft anschließend das Ergebnis der Faltung. Wenn der
 Schwellwert nicht überschritten wird, gibt es keinen genügend großen Anstieg des Gradienten und das Ergebnis wird auf
 $0$ gesetzt. Wird der Schwellwert überschritten, handelt es sich um einen Edgel und das Ergebnis wird in den
 Bedingungen von Zeile \ref{alg:findedgels-horizontal-maxima} weiter untersucht, ob es sich um ein lokales Maximum
 handelt. Ein lokales Maximum bedeutet, dass ein Edgel einen größeren Gradienten besitzt als seine beiden Nachbarn. Die
 Bedingung in Zeile \ref{alg:findedgels-horizontal-maxima} wird bei der ersten Überprüfung immer fehlschlagen.
 Dadurch wird sichergestellt, dass kein Maximum an den Rändern existiert, da hier nicht genügend Nachbarn vorhanden sind
 um eine verlässliche Aussage zu treffen. Zeile \ref{alg:findedgels-horizontal-copy-prev1} und
 Zeile \ref{alg:findedgels-horizontal-copy-edgel} kopieren die Werte für den nächsten Durchlauf. Durch das kopieren der
 Werte werden die Nachbarn für den nächsten Durchlauf um eine Position weiterverschoben. Nur bei einem lokalen Maximum
 (Zeile \ref{alg:findedgels-horizontal-maxima}--\ref{alg:findedgels-horizontal-maxima-end}) wird die Position des
 Edgels gespeichert (Vgl. \autoref{alg:vectorsetcoordinate}, S. \pageref{alg:vectorsetcoordinate}), und seine
 Orientierung berechnet (Vgl. \autoref{alg:gradientintensity}, S. \pageref{alg:gradientintensity}). Der Edgel wird mit
 \textproc{addEdgel} (\autoref{alg:edgelpool-addedgel}, S. \pageref{alg:edgelpool-addedgel}) in einem Speicherblock zu
 weiteren Verarbeitung gespeichert. Sind alle Pixel auf einer Scanline untersucht, wird in Zeile
 \ref{alg:findedgels-horizontal-increment} die nächste Scanline ausgewählt. Das Verfahren wird solange wiederholt, bis
 alle Scanlines innerhalb der Region untersucht wurden. \autoref{alg:findedgels-vertical} untersucht die vertikalen
 Scanlines in Zeile \ref{alg:findedgels-vertical-scanlinestart}--\ref{alg:findedgels-vertical-scanlineend} analog zu
 \autoref{alg:findedgels-horizontal} Zeile
 \ref{alg:findedgels-horizontal-scanlinestart}--\ref{alg:findedgels-horizontal-scanlineend}.
\input{alg/analyse-hirzer/findedgelsclarke2}

In \autoref{alg:findedgels-horizontal-analyse} und \autoref{alg:findedgels-vertical-analyse} sind die Kosten von
 \textproc{findEdgels} aufgeführt.
\input{alg/analyse-hirzer/findedgelsclarke3}
Die bereits vorgestellten Methoden \textproc{vectorSetCoordinate} (\autoref{alg:vectorsetcoordinate}) und
 \textproc{addEdgel} (\autoref{alg:edgelpool-addedgel}) haben eine konstante Laufzeit. Die Methoden
 \textproc{convoluteKernelX}, \textproc{convoluteKernelY} und \textproc{gradientIntensity} haben ebenfalls eine
 konstante Laufzeit, die zu einem späteren Zeitpunkt bewiesen wird.  Die Laufzeit von
 \autoref{alg:findedgels-horizontal-analyse} lässt sich wie in \autoref{eq:findedgels1} zusammenfassen.
\input{eq/hirzer/findedgels1}
Der Algorithmus ist von den Variablen $t$, $l$ und $\mathit{regionSize}$ abhängig. Der Bereich
 $[t,t+\mathit{regionSize})$ und $[l,l+\mathit{regionSize})$ wird in der Analyse als $[t,t+\mathit{regionSize}) = n$
 und $[l,l+\mathit{regionSize}) = m$ bezeichnet. Durch Umformung in \autoref{eq:findedgels2} werden die Konstanten
 isoliert, was zu einer Laufzeit von $T(n,m) = \Theta(\tfrac{nm}{5})$ für \autoref{alg:findedgels-horizontal-analyse}
 führt (\autoref{eq:findedgels3}). Die Kosten für \textproc{findEdgels} zur Untersuchung der vertikalen Scanline sind in
 \autoref{alg:findedgels-vertical-analyse} aufgeführt und entsprechen den Kosten von
 \autoref{alg:findedgels-horizontal-analyse}.
\input{alg/analyse-hirzer/findedgelsclarke4}
Die Kosten des Algorithmus sind in \autoref{eq:findedgels4} aufgeführt und durch Umformung in \autoref{eq:findedgels5}
 werden die Konstanten isoliert.
\input{eq/hirzer/findedgels2}
Dies führt zu einer Laufzeit von $T(n,m) = \Theta(\tfrac{nm}{5})$ für \autoref{alg:findedgels-vertical-analyse}
 (\autoref{eq:findedgels6}).
Um die Laufzeit von \textproc{findEdgels} zu bestimmen, werden die Laufzeiten von
 \autoref{alg:findedgels-horizontal-analyse} und \autoref{alg:findedgels-vertical-analyse} in \autoref{eq:findedgels7}
 zusammengefasst.
\input{eq/hirzer/findedgels3}
Durch Umformung in \autoref{eq:findedgels8} kann die Laufzeit des Algorithmus in \autoref{eq:findedgels9} ermittelt
 werden. Die Laufzeit von \textproc{findEdgels} entspricht demnach $T(n,m) = \Theta(\tfrac{nm}{5})$.

\autoref{alg:convolutekernel-horizontal} und \autoref{alg:convolutekernel-vertical} berechnen den Gradienten durch Faltung mit dem Gauß-Kernel
$\left( \begin{smallmatrix}
-3& -5& 0& 5& 3
\end{smallmatrix} \right)$
 auf der horizontalen und vertikalen Scanline. Als Parameter benötigt der Algorithmus den Zeiger des monochromen
 Bildsignals $I_m$, die Position des Pixels ($x$ und $y$), sowie die Breite $w$ und Höhe $h$ von $I_m$. In Zeile
 \ref{alg:convolutekernel-horizontal-readstart}--\ref{alg:convolutekernel-horizontal-readend} werden durch die
 Funktion \textproc{getpixel} (Vgl. \autoref{alg:getpixel}, S. \pageref{alg:getpixel}) die benötigten Pixelwerte
 ausgelesen und den Variablen zugewiesen. Im Anschluss werden die Werte mit dem Gauß-Kernel
$\left( \begin{smallmatrix}
-3& -5& 0& 5& 3
\end{smallmatrix} \right)$
berechnet um den Gradienten zu bestimmen.
\input{alg/analyse-hirzer/convolutekernelx}
Bei genauer Betrachtung von \autoref{alg:convolutekernel-horizontal} und \autoref{alg:convolutekernel-vertical}
 fällt auf, dass der Wert $p_3$ in der Berechnung nicht vorkommt.
\input{alg/analyse-hirzer/convolutekernely}
Dies ist darauf zurückzuführen, dass der Gauß-Kernel an der dritten Stelle mit $0$ definiert ist. Somit kann die
 Multiplikation vernachlässigt werden. Die Laufzeit von \autoref{alg:convolutekernel-horizontal} und
 \autoref{alg:convolutekernel-vertical} ist konstant.

In \autoref{alg:gradientintensity} wird mittels Faltung die Orientierung eines \glspl{edgel} bestimmt. Als
 Eingabeparameter wird das monochrome Bildsignal $I_m$, dessen Breite $w$ und Höhe $h$, sowie die Position des
 \glspl{edgel} ($x,y$) benötigt.
\input{alg/analyse-hirzer/gradientintensity}
In Zeile \ref{alg:gradientintensity-readstart}--\ref{alg:gradientintensity-readend} werden die Pixelwerte ausgelesen
 und den Variablen zugewiesen. In Zeile
 \ref{alg:gradientintensity-convolutestart}--\ref{alg:gradientintensity-convoluteend} erfolgt die Faltung mit dem
 Sobel-Operator\footcite[Vgl.][S.~120--123]{burger05}, dessen Filter
\begin{subequations}
\begin{align}
	H_x =&
	\begin{pmatrix}
		1& 0& -1\\
		2& 0& -2\\
		1& 0& -1
	\end{pmatrix}
\end{align}
\begin{align}
	H_y =&
	\begin{pmatrix}
		1& 2& 1\\
		0& 0& 0\\
		-1& -2& -1
	\end{pmatrix}
\end{align}
\end{subequations}
den Gradienten $G_x$ und $G_y$ bestimmen. Wie in \autoref{alg:convolutekernel-horizontal} werden Multiplikationen von
 $0$-Werten des Filters vernachlässigt. Mit
\begin{equation}
	\label{eq:orientation}
	\Phi(x,y) = \arctan{\left(\tfrac{G_y}{G_x}\right)}
\end{equation}
kann die Orientierung berechnet werden. $G_x$ und $G_y$ werden mit \autoref{alg:vectorsetcoordinate} als
 \textproc{vector} gespeichert und normalisiert
 (Zeile \ref{alg:gradientintensity-vector-start}--\ref{alg:gradientintensity-vector-end}). Die Laufzeit von
 \autoref{alg:gradientintensity} ist konstant.

Um aus den gefundenen \glspl{edgel} Liniensegmente zu erzeugen, wird \autoref{alg:findlinesegments1} verwendet. Das
 Verfahren benötigt den Speicherblock $E$, in dem die \glspl{edgel} vorliegen, und den Speicherblock $L$, der zur
 Speicherung der gefundenen Liniensegmente dient.

\input{alg/analyse-hirzer/findlinesegments-1}

In Zeile \ref{alg:findlinesegments1-init-start}--\ref{alg:findlinesegments1-init-end} wird die Variable
 $\mathit{presentLine}$ initialisiert. Diese Variable enthält das zu speichernde Liniensegment im Verfahren.
 Die Zählvariable $\mathit{edgelsInRegion}$ wird mit $0$ initialisiert und speichert die Anzahl der \gls{edgel} in
 einer Region. In der Schleife von Zeile \ref{alg:findlinesegments1-loop-start} bis Zeile
 \ref{alg:findlinesegments1-loop-end} wird das RANSAC-Verfahren wiederholt, solange das zu untersuchende Liniensegment
 genügend Unterstützung durch \gls{edgel} besitzt und genügend \gls{edgel} in der Region vorhanden sind. Die Anzahl der
 unterstützenden \gls{edgel} wird in Zeile \ref{alg:findlinesegments1-clearsupport} für jeden Durchlauf gelöscht.
 Danach wird in Zeile \ref{alg:findlinesegments1-line-start}--\ref{alg:findlinesegments1-line-end} ein zufälliges
 Liniensegment in der Region erstellt und untersucht
 (Vgl. \autoref{alg:findlinesegments2}--\autoref{alg:findlinesegments4}). Die Erstellung eines Liniensegments wird
 mehrmahls wiederholt, um das Liniensegment mit den meisten Unterstützungsedgels zu finden. In Zeile
 \ref{alg:findlinesegments1-hasenoughsupport} wird die Anzahl der der unterstützenden \gls{edgel} mit der Anzahl der
 benötigten \gls{edgel} verglichen. Nur wenn genügend \gls{edgel} das Liniensegment unterstützen, wird in
 \autoref{alg:findlinesegments5}--\autoref{alg:findlinesegments7} das Verfahren fortgesetzt und die
 Unterstützungsedgels aus dem Speicherblock $E$ entfernt.

In \autoref{alg:findlinesegments2} wird die Initialisierung der Variablen vorgenommen, die zur Erstellung eines
 Liniensegments benötigt werden. Die Variablen $\mathit{start}$ und $\mathit{end}$ werden als Indizes für \gls{edgel}
 benutzt. Die Variable $\mathit{maxIteration}$ gibt die maximale Anzahl der Interationen an, die $\mathit{iterator}$
 durchlaufen kann. $\mathit{first}$ ist der Startedgel und $\mathit{last}$ der Endedgel des Liniensegments. In
 $\mathit{numberOfEdgels}$ wird die Anzahl der \gls{edgel} in $E$ gespeichert.

\input{alg/analyse-hirzer/findlinesegments-2}

Die Auswahl eines Liniensegments erfolgt mit \autoref{alg:findlinesegments3}. Zeile
 \ref{alg:findlinesegments3-loop-start}--\ref{alg:findlinesegments3-loop-end} ist dafür verantwortlich, solange nach
 einem Liniensegment zu suchen, bis der erste und letzte \gls{edgel} sich unterscheiden oder ihre Orientierung
 zueinander kompatibel ist. Als letzte Bedingung muss die Anzahl der Iterationen unterhalb des festgelegten
 Schwellwerts $\mathit{maxIteration}$ bleiben.

\input{alg/analyse-hirzer/findlinesegments-3}

In Zeile \ref{alg:findlinesegments3-first} und Zeile \ref{alg:findlinesegments3-last} werden zufällig zwei Indizes aus
 der Menge der vorhandenen \gls{edgel} errechnet. Diese werden in Zeile
 \ref{alg:findlinesegments3-start}--\ref{alg:findlinesegments3-end} verwendet, um die beiden \gls{edgel}
 $\mathit{start}$ und $\mathit{end}$ auszuwählen. Der Iterator wird anschliessend in Zeile
 \ref{alg:findlinesegments3-inc} inkrementiert.

Wenn in \autoref{alg:findlinesegments3} ein Liniensegment erstellt wurde, werden in \autoref{alg:findlinesegments4} die
 \gls{edgel} zur unterstüztung der Hypothese hinzugefügt. Dazu wird in Zeile \ref{alg:findlinesegments4-isbelowmax}
 überprüft, ob die maximale Anzahl der Iterationen nicht überschritten wurde. Falls dem so ist wird
 \autoref{alg:findlinesegments4} nicht weiter ausgeführt. Andernfalls wird in Zeile
 \ref{alg:findlinesegments4-init-start}--\ref{alg:findlinesegments4-init-end} die Variable $\mathit{segment}$ zur
 Speicherung des Liniensegments vorbereitet und der Start- und Endedgel, sowie die Orientierung zugewiesen. Die Anzahl
 der Unterstützungedgels beträgt zu diesem Zeitpunkt noch $0$.

\input{alg/analyse-hirzer/findlinesegments-4}

In der Schleife in Zeile \ref{alg:findlinesegments4-loop-start}--\ref{alg:findlinesegments4-loop-end} werden die
 \gls{edgel} gezählt, die die Linienhypothese unterstützen. Dazu wird in Zeile \ref{alg:findlinesegments4-edgel} ein
 \gls{edgel} ausgewählt und in Zeile \ref{alg:findlinesegments4-isedgelnearline} untersucht, ob der Abstand zur Linie
 klein genug ist. Wenn nicht, wird in Zeile \ref{alg:findlinesegments4-inc} die Laufvariable $j$ inkrementiert und das
 nächste \gls{edgel} ausgewählt. Wenn ein \gls{edgel} nahe genug an dem Liniensegment liegt, wird es in Zeile
 \ref{alg:findlinesegments4-addedgel} dem Liniensegment hinzugefügt und die Anzahl der Unterstützungsedgel wird in
 Zeile \ref{alg:findlinesegments4-count} erhöht. Nachdem alle \gls{edgel} untersucht wurden, wird in Zeile
 \ref{alg:findlinesegments4-hasmoresupport} überprüft, ob die Anzahl der \gls{edgel} des Liniensegments
 $\mathit{segment}$ größer ist als die Anzahl der \gls{edgel} in $\mathit{presentLine}$. Im Falle, dass
 $\mathit{segment}$ mehr Unterstützungsedgel besitzt, wird das Liniensegment in $\mathit{presentLine}$ gespeichert.
 Durch die Wiederholung in \autoref{alg:findlinesegments1} wird sichergestellt, dass das Liniensegment mit der
 größten Unterstützung ausgewählt wird.

Nachdem ein Liniensegment mit genügend Unterstützung ausgewählt wurde, kann mit \autoref{alg:findlinesegments5} die
 Start- und Endposition des Liniensegments bestimmt werden. Da ein Liniensegment aus zwei zufällig ausgewählten
 \glspl{edgel} besteht, können diese \gls{edgel} und die tatsächlichen Start- und Endpunkte voneinander abweichen
 (Vgl. \autoref{fig:})

\input{alg/analyse-hirzer/findlinesegments-5}

In Zeile \ref{alg:findlinesegments5-start}--\ref{alg:findlinesegments5-end} wird dazu die Variable $\mathit{start}$ mit
 einem kleinen Wert, und die Variable $\mathit{end}$ mit einem großen Wert, initialisiert. Die Steigung des
 Liniensegments und die Orhogonale werden in Zeile
 \ref{alg:findlinesegments5-slope-start}--\ref{alg:findlinesegments5-slope-end} berechnet. In Zeile
 \ref{alg:findlinesegments5-isxsmaller} wird geprüft, ob der Absolutwert der Steigung an Punkt $x$ kleiner ist als der
 Punkt $y$. Falls dem so ist, wird in Zeile
 \ref{alg:findlinesegments5-newstart-start}--\ref{alg:findlinesegments5-newstart-end} ein neuer Start- und Endpunkt
 gesucht, indem die $y$-Koordinate aller Unterstützungsedgels des Liniensegments verglichen werden. Andernfalls wird in
 \autoref{alg:findlinesegments6} in Zeile
 \ref{alg:findlinesegments6-newstart-start}--\ref{alg:findlinesegments6-newstart-end} ein neuer Start- und Endpunkt
 gesucht, indem die $x$-Koordiante aller \glspl{edgel} des Liniensegments untersucht und verglichen werden. Am Ende von
 \autoref{alg:findlinesegments6} ist in $\mathit{presentLine}$ ein neuer Start- und Endpunkt gespeichert.

\input{alg/analyse-hirzer/findlinesegments-6}

In \autoref{alg:findlinesegments7} wird nun geprüft, ob der Start- und Endpunkt vertauscht ist. Dazu wird der Winkel
 zwischen dem Liniensegment und seiner Orthogonalen gebildet. Wenn der Winkel kleiner als $0$ ist, werden Start- und
 Endpunkt in Zeile \ref{alg:findlinesegments7-newstart-start}--\ref{alg:findlinesegments7-newstart-end} getauscht. Im
 Anschluss daran, wird in Zeile \ref{alg:findlinesegments7-save-start}--\ref{alg:findlinesegments7-save-end} die
 Orientierung des Liniensegments berechnet und gespeichert. Danach wird das Liniensegment in Zeile
 \ref{alg:findlinesegments7-addtomempool} in den Speicherblock $L$ hinterlegt. Jetzt müssen alle Unterstützungsedgel
 des Liniensegments in Zeile \ref{alg:findlinesegments7-removeedgel-start}--\ref{alg:findlinesegments7-removeedgel-end}
 aus dem Speicherblock $E$ entfernt werden. Das entfernen der Unterstützungsedgel bewirkt, dass entweder das
 RANSAC-Verfahren wiederholt werden kann ohne die gleichen \gls{edgel} erneut zu betrachten, oder, wenn nicht mehr
 genügend \gls{edgel} in der Region vorhanden sind, das Verfahren abzubrechen und die Linienerkennung zu beenden.

\input{alg/analyse-hirzer/findlinesegments-7}
