Der Algorithmus von \citeauthor{clarke96} ist in \autoref{alg:linedetection-clarke} aufgeführt und benötigt das
 monochrome Bildsignal $I_m$. In der doppelten Schleife in Zeile \ref{alg:linedetection-clarke-start} bis
 \ref{alg:linedetection-clarke-end} wird $I_m$ in Regionen der Größe $40 \times 40$ \gls{pixel} unterteilt. Die
 globalen Variablen $\mathit{imageWidth}$ und $\mathit{imageHeight}$ enthalten die Breite und Höhe des Bildsignals
 $I_m$. Die Regionengröße von $40$ \gls{pixel} ist in der globalen Variable $\mathit{regionSize}$ gespeichert. In
 \citeauthor{clarke96}\footcite{clarke96} sind keine Hintergrundinformationen zu der Größe einer Region angegeben.
 Betrachtet man $640 \bmod 40 = 0$ und $480 \bmod 40 = 0$ ist ersichtlich, dass die Größe der Region und der Aufteilung
 des Bildsignals in Zusammenhang steht. In Zeile
 \ref{alg:linedetection-clarke-call-start}--\ref{alg:linedetection-clarke-call-end} werden zuerst \glspl{edgel}
 ermittelt, um im Anschluss daraus Liniensegmente zu erstellen. Wenn für eine Region Liniensegmente erstellt und
 gespeichert wurden, wird der Speicherblock der \gls{edgel} und Liniensegmente in Zeile
 \ref{alg:linedetection-clarke-reset-start}--\ref{alg:linedetection-clarke-reset-end} gelöscht.

\input{alg/analyse-hirzer/linedetection-clarke}

\begin{subequations}
\begin{align}
\label{eq:linedetection-analyze1}
T(I)& =
c_1
+ c_2
+ c_3 \left(\frac{h}{40} + 1\right)
+ c_4 \sum \limits_{y = 0}^{\frac{h}{40}} t_y \left(\frac{w}{40} + 1 \right)
+ c_5 \sum \limits_{y = 0}^{\frac{h}{40}} \sum \limits_{x = 0}^{\frac{w}{40}} t_y t_x\\
& \quad + c_6 \sum \limits_{y = 0}^{\frac{h}{40}} \sum \limits_{x = 0}^{\frac{w}{40}} t_y t_x
+ c_7 \sum \limits_{y = 0}^{\frac{h}{40}} \sum \limits_{x = 0}^{\frac{w}{40}} t_y t_x
+ c_9 \sum \limits_{y = 0}^{\frac{h}{40}} t_y \nonumber \\
\label{eq:linedetection-analyze2}
T(I)& =
c_1
+ c_2
+ c_3 \left(n + 1\right)
+ c_4 \sum \limits_{y = 0}^{n} t_y \left(k + 1 \right)
+ c_5 \sum \limits_{y = 0}^{n} \sum \limits_{x = 0}^{k} t_y t_x\\
& \quad + c_6 \sum \limits_{y = 0}^{n} \sum \limits_{x = 0}^{k} t_y t_x
+ c_7 \sum \limits_{y = 0}^{n} \sum \limits_{x = 0}^{k} t_y t_x
+ c_9 \sum \limits_{y = 0}^{n} t_y \nonumber \\
\label{eq:linedetection-analyze3}
T(I)& =
c_1
+ c_2
+ c_3 \left(n + 1\right)
+ c_4 \left[n \left(k + 1 \right)\right]
+ c_5 n k
+ c_6 n k
+ c_7 n k
+ c_9 n\\
\label{eq:linedetection-analyze4}
T(I)& = c_1 + c_2 + c_3 + \left(c_3 + c_4 + c_9\right) n + \left(c_4 + c_5 + c_6 + c_7\right) n k\\
\label{eq:linedetection-analyze5}
T(I)& = \Theta(nk)
\end{align}
\end{subequations}

Das Verfahren zur Bestimmung der Edgels (\autoref{alg:findedgels-horizontal} und \autoref{alg:findedgels-vertical})
 benötigt das monochrome Bildsignal $I_m$, sowie die Position der oberen linken Ecke der Region, die durch oben $t$ und
 links $l$ definiert ist. Der Zeiger $E$ wird zur Speicherung der gefundenen \glspl{edgel} verwendet.

\input{alg/analyse-hirzer/findedgels}

Zeile \ref{alg:findedgels-horizontal-scanlinestart}--\ref{alg:findedgels-horizontal-scanlineend} ist für den Aufbau der
 horizontalen Scanlines verantwortlich. Die Überprüfung sorgt dafür, dass die Scanlines bis zum Ende der Region im
 Abstand von $5$ Pixeln untersucht werden. Nach der Initialisierung der Variablen wird in der Schleife von
 Zeile~\ref{alg:findedgels-horizontal-loopstart}--\ref{alg:findedgels-horizontal-loopend} jeder Pixel auf der Scanline
 untersucht. Zuerst wird in Zeile \ref{alg:findedgels-horizontal-convolute} die Faltung mit einem Gauß-Kernel
 vorgenommen (Vgl. \autoref{alg:convolutekernel-horizontal}, S. \pageref{alg:convolutekernel-horizontal}). Der Test
 in Zeile \ref{alg:findedgels-horizontal-foundedgel} überprüft anschließend das Ergebnis der Faltung. Wenn der
 Schwellwert nicht überschritten wird, gibt es keinen genügend großen Anstieg des Gradienten und das Ergebnis wird auf
 $0$ gesetzt. Wird der Schwellwert überschritten, handelt es sich um einen Edgel und das Ergebnis wird in den
 Bedingungen von Zeile \ref{alg:findedgels-horizontal-maxima} weiter untersucht, ob es sich um ein lokales Maximum
 handelt. Ein lokales Maximum bedeutet, dass ein Edgel einen größeren Gradienten besitzt als seine beiden Nachbarn.

Die Bedingung in Zeile \ref{alg:findedgels-horizontal-maxima} wird bei der ersten Überprüfung immer fehlschlagen.
 Dadurch wird sichergestellt, dass kein Maximum an den Rändern existiert, da hier nicht genügend Nachbarn vorhanden sind
 um eine verlässliche Aussage zu treffen. Zeile \ref{alg:findedgels-horizontal-copy-prev1} und
 Zeile \ref{alg:findedgels-horizontal-copy-edgel} kopieren die Werte für den nächsten Durchlauf. Durch das kopieren der
 Werte werden die Nachbarn für den nächsten Durchlauf um eine Position weiterverschoben. Nur bei einem lokalen Maximum
 (Zeile \ref{alg:findedgels-horizontal-maxima}--\ref{alg:findedgels-horizontal-maxima-end}) wird die Position des
 Edgels gespeichert (Vgl. \autoref{alg:vectorsetcoordinate}), und seine Orientierung
 (Vlg. \autoref{alg:gradientintensity}, S. \pageref{alg:gradientintensity}) berechnet. Der Edgel wird mit
 \autoref{alg:edgelpool-addedgel} in einem Speicherblock zu weiteren Verarbeitung gespeichert. Sind alle Pixel auf
 einer Scanline untersucht, wird in Zeile \ref{alg:findedgels-horizontal-increment} die nächste Scanline ausgewählt.
 Das Verfahren wird solange wiederholt, bis alle Scanlines innerhalb der Region untersucht wurden.
 \autoref{alg:findedgels-vertical} untersucht die vertikalen Scanlines in Zeile
 \ref{alg:findedgels-vertical-scanlinestart}--\ref{alg:findedgels-vertical-scanlineend} analog zu
 \autoref{alg:findedgels-horizontal} Zeile
 \ref{alg:findedgels-horizontal-scanlinestart}--\ref{alg:findedgels-horizontal-scanlineend}.

\autoref{alg:convolutekernel-horizontal} und \autoref{alg:convolutekernel-vertical} berechnen den Gradienten durch Faltung mit dem Gauß-Kernel
$\left( \begin{smallmatrix}
-3& -5& 0& 5& 3
\end{smallmatrix} \right)$
 auf der horizontalen und vertikalen Scanline. Als Parameter benötigt der Algorithmus den Zeiger des monochromen
 Bildsignals $I_m$, die Position des Pixels ($x$ und $y$), sowie die Breite $w$ und Höhe $h$ von $I_m$. In Zeile
 \ref{alg:convolutekernel-horizontal-readstart}--\ref{alg:convolutekernel-horizontal-readend} werden durch die
 Funktion \textproc{getpixel} (Vgl. \autoref{alg:getpixel}, S. \pageref{alg:getpixel}) die benötigten Pixelwerte
 ausgelesen und den Variablen zugewiesen. Im Anschluss werden die Werte mit dem Gauß-Kernel
$\left( \begin{smallmatrix}
-3& -5& 0& 5& 3
\end{smallmatrix} \right)$
berechnet um den Gradienten zu bestimmen.

\input{alg/analyse-hirzer/convolutekernel}

Bei genauer Betrachtung von \autoref{alg:convolutekernel-horizontal} und \autoref{alg:convolutekernel-vertical}
 fällt auf, dass der Wert $p_3$ in der Berechnung nicht vorkommt. Dies ist darauf zurückzuführen, dass der Gauß-Kernel
 an der dritten Stelle mit $0$ definiert ist. Somit kann die Multiplikation vernachlässigt werden. Die Laufzeit von
 \autoref{alg:convolutekernel-horizontal} und \autoref{alg:convolutekernel-vertical} ist konstant.

In \autoref{alg:gradientintensity} wird mittels Faltung die Orientierung eines \glspl{edgel} bestimmt. Als
 Eingabeparameter wird das monochrome Bildsignal $I_m$, dessen Breite $w$ und Höhe $h$, sowie die Position des
 \glspl{edgel} ($x,y$) benötigt.

\input{alg/analyse-hirzer/gradientintensity}

In Zeile \ref{alg:gradientintensity-readstart}--\ref{alg:gradientintensity-readend} werden die Pixelwerte ausgelesen
 und den Variablen zugewiesen. In
 Zeile\ref{alg:gradientintensity-convolutestart}--\ref{alg:gradientintensity-convoluteend} erfolgt die Faltung mit dem
 Sobel-Operator\footcite[Vgl.][S.~120--123]{burger05}, dessen Filter

\begin{subequations}
\begin{align}
	H_x =&
	\begin{pmatrix}
		1& 0& -1\\
		2& 0& -2\\
		1& 0& -1
	\end{pmatrix}
\end{align}
\begin{align}
	H_y =&
	\begin{pmatrix}
		1& 2& 1\\
		0& 0& 0\\
		-1& -2& -1
	\end{pmatrix}
\end{align}
\end{subequations}

den Gradienten $G_x$ und $G_y$ bestimmen. Wie in \autoref{alg:convolutekernel-horizontal} werden Multiplikationen von
 $0$-Werten des Filters vernachlässigt. Mit

\begin{equation}
	\label{eq:orientation}
	\Phi(x,y) = \arctan{\left(\tfrac{G_y}{G_x}\right)}
\end{equation}

kann die Orientierung berechnet werden. $G_x$ und $G_y$ werden mit \autoref{alg:vectorsetcoordinate} als
 \textproc{vector} gespeichert und normalisiert
 (Zeile \ref{alg:gradientintensity-vector-start}--\ref{alg:gradientintensity-vector-end}). Die Laufzeit von
 \autoref{alg:gradientintensity} ist konstant.

Um aus den gefundenen \glspl{edgel} Liniensegmente zu erzeugen, wird \autoref{alg:findlinesegments1} verwendet. Das
 Verfahren benötigt den Speicherblock $E$, in dem die \glspl{edgel} vorliegen, und den Speicherblock $L$, der zur
 Speicherung der gefundenen Liniensegmente dient.

\input{alg/analyse-hirzer/findlinesegments-1}

In Zeile \ref{alg:findlinesegments1-init-start}--\ref{alg:findlinesegments1-init-end} wird die Variable
 $\mathit{presentLine}$ initialisiert. Diese Variable enthält das zu speichernde Liniensegment im Verfahren.
 Die Zählvariable $\mathit{edgelsInRegion}$ wird mit $0$ initialisiert und speichert die Anzahl der \gls{edgel} in
 einer Region. In der Schleife von Zeile \ref{alg:findlinesegments1-loop-start} bis Zeile
 \ref{alg:findlinesegments1-loop-end} wird das RANSAC-Verfahren wiederholt, solange das zu untersuchende Liniensegment
 genügend Unterstützung durch \gls{edgel} besitzt und genügend \gls{edgel} in der Region vorhanden sind. Die Anzahl der
 unterstützenden \gls{edgel} wird in Zeile \ref{alg:findlinesegments1-clearsupport} für jeden Durchlauf gelöscht.
 Danach wird in Zeile \ref{alg:findlinesegments1-line-start}--\ref{alg:findlinesegments1-line-end} ein zufälliges
 Liniensegment in der Region erstellt und untersucht
 (Vgl. \autoref{alg:findlinesegments2}--\autoref{alg:findlinesegments4}). Die Erstellung eines Liniensegments wird
 mehrmahls wiederholt, um das Liniensegment mit den meisten Unterstützungsedgels zu finden. In Zeile
 \ref{alg:findlinesegments1-hasenoughsupport} wird die Anzahl der der unterstützenden \gls{edgel} mit der Anzahl der
 benötigten \gls{edgel} verglichen. Nur wenn genügend \gls{edgel} das Liniensegment unterstützen, wird in
 \autoref{alg:findlinesegments5}--\autoref{alg:findlinesegments7} das Verfahren fortgesetzt und die
 Unterstützungsedgels aus dem Speicherblock $E$ entfernt.

In \autoref{alg:findlinesegments2} wird die Initialisierung der Variablen vorgenommen, die zur Erstellung eines
 Liniensegments benötigt werden. Die Variablen $\mathit{start}$ und $\mathit{end}$ werden als Indizes für \gls{edgel}
 benutzt. Die Variable $\mathit{maxIteration}$ gibt die maximale Anzahl der Interationen an, die $\mathit{iterator}$
 durchlaufen kann. $\mathit{first}$ ist der Startedgel und $\mathit{last}$ der Endedgel des Liniensegments. In
 $\mathit{numberOfEdgels}$ wird die Anzahl der \gls{edgel} in $E$ gespeichert.

\input{alg/analyse-hirzer/findlinesegments-2}

Die Auswahl eines Liniensegments erfolgt mit \autoref{alg:findlinesegments3}. Zeile
 \ref{alg:findlinesegments3-loop-start}--\ref{alg:findlinesegments3-loop-end} ist dafür verantwortlich, solange nach
 einem Liniensegment zu suchen, bis der erste und letzte \gls{edgel} sich unterscheiden oder ihre Orientierung
 zueinander kompatibel ist. Als letzte Bedingung muss die Anzahl der Iterationen unterhalb des festgelegten
 Schwellwerts $\mathit{maxIteration}$ bleiben.

\input{alg/analyse-hirzer/findlinesegments-3}

In Zeile \ref{alg:findlinesegments3-first} und Zeile \ref{alg:findlinesegments3-last} werden zufällig zwei Indizes aus
 der Menge der vorhandenen \gls{edgel} errechnet. Diese werden in Zeile
 \ref{alg:findlinesegments3-start}--\ref{alg:findlinesegments3-end} verwendet, um die beiden \gls{edgel}
 $\mathit{start}$ und $\mathit{end}$ auszuwählen. Der Iterator wird anschliessend in Zeile
 \ref{alg:findlinesegments3-inc} inkrementiert.

Wenn in \autoref{alg:findlinesegments3} ein Liniensegment erstellt wurde, werden in \autoref{alg:findlinesegments4} die
 \gls{edgel} zur unterstüztung der Hypothese hinzugefügt. Dazu wird in Zeile \ref{alg:findlinesegments4-isbelowmax}
 überprüft, ob die maximale Anzahl der Iterationen nicht überschritten wurde. Falls dem so ist wird
 \autoref{alg:findlinesegments4} nicht weiter ausgeführt. Andernfalls wird in Zeile
 \ref{alg:findlinesegments4-init-start}--\ref{alg:findlinesegments4-init-end} die Variable $\mathit{segment}$ zur
 Speicherung des Liniensegments vorbereitet und der Start- und Endedgel, sowie die Orientierung zugewiesen. Die Anzahl
 der Unterstützungedgels beträgt zu diesem Zeitpunkt noch $0$.

\input{alg/analyse-hirzer/findlinesegments-4}

In der Schleife in Zeile \ref{alg:findlinesegments4-loop-start}--\ref{alg:findlinesegments4-loop-end} werden die
 \gls{edgel} gezählt, die die Linienhypothese unterstützen. Dazu wird in Zeile \ref{alg:findlinesegments4-edgel} ein
 \gls{edgel} ausgewählt und in Zeile \ref{alg:findlinesegments4-isedgelnearline} untersucht, ob der Abstand zur Linie
 klein genug ist. Wenn nicht, wird in Zeile \ref{alg:findlinesegments4-inc} die Laufvariable $j$ inkrementiert und das
 nächste \gls{edgel} ausgewählt. Wenn ein \gls{edgel} nahe genug an dem Liniensegment liegt, wird es in Zeile
 \ref{alg:findlinesegments4-addedgel} dem Liniensegment hinzugefügt und die Anzahl der Unterstützungsedgel wird in
 Zeile \ref{alg:findlinesegments4-count} erhöht. Nachdem alle \gls{edgel} untersucht wurden, wird in Zeile
 \ref{alg:findlinesegments4-hasmoresupport} überprüft, ob die Anzahl der \gls{edgel} des Liniensegments
 $\mathit{segment}$ größer ist als die Anzahl der \gls{edgel} in $\mathit{presentLine}$. Im Falle, dass
 $\mathit{segment}$ mehr Unterstützungsedgel besitzt, wird das Liniensegment in $\mathit{presentLine}$ gespeichert.
 Dadurch wird durch die Wiederholung in \autoref{alg:findlinesegments1} sichergestellt, dass das Liniensegment mit der
 größten Unterstützung ausgewählt wird.
