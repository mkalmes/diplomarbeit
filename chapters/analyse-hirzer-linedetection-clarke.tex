Der Algorithmus von \citeauthor{clarke96} ist in \autoref{alg:linedetection-clarke} aufgeführt und benötigt das
 monochrome Bildsignal $I_m$. In der doppelten Schleife in Zeile \ref{alg:linedetection-clarke-start} bis
 \ref{alg:linedetection-clarke-end} wird $I_m$ in Regionen der Größe $40 \times 40$ \gls{pixel} unterteilt. Die
 globalen Variablen $\mathit{imageWidth}$ und $\mathit{imageHeight}$ enthalten die Breite und Höhe des Bildsignals
 $I_m$. Die Regionengröße von $40$ \gls{pixel} ist in der globalen Variable $\mathit{regionSize}$ gespeichert. In
 \citeauthor{clarke96}\footcite{clarke96} sind keine Hintergrundinformationen zu der Größe einer Region angegeben.
 Betrachtet man $640 \bmod 40 = 0$ und $480 \bmod 40 = 0$ ist ersichtlich, dass die Größe der Region und der Aufteilung
 des Bildsignals in Zusammenhang steht. In Zeile
 \ref{alg:linedetection-clarke-call-start}--\ref{alg:linedetection-clarke-call-end} werden zuerst \glspl{edgel}
 ermittelt, um im Anschluss daraus Liniensegmente zu erstellen. Wenn für eine Region Liniensegmente erstellt und
 gespeichert wurden, wird der Speicherblock der \gls{edgel} und Liniensegmente in Zeile
 \ref{alg:linedetection-clarke-reset-start}--\ref{alg:linedetection-clarke-reset-end} gelöscht.

\input{alg/analyse-hirzer/linedetection-clarke}

\begin{subequations}
\begin{align}
\label{eq:linedetection-analyze1}
T(I)& =
c_1
+ c_2
+ c_3 \left(\frac{h}{40} + 1\right)
+ c_4 \sum \limits_{y = 0}^{\frac{h}{40}} t_y \left(\frac{w}{40} + 1 \right)
+ c_5 \sum \limits_{y = 0}^{\frac{h}{40}} \sum \limits_{x = 0}^{\frac{w}{40}} t_y t_x\\
& \quad + c_6 \sum \limits_{y = 0}^{\frac{h}{40}} \sum \limits_{x = 0}^{\frac{w}{40}} t_y t_x
+ c_7 \sum \limits_{y = 0}^{\frac{h}{40}} \sum \limits_{x = 0}^{\frac{w}{40}} t_y t_x
+ c_9 \sum \limits_{y = 0}^{\frac{h}{40}} t_y \nonumber \\
\label{eq:linedetection-analyze2}
T(I)& =
c_1
+ c_2
+ c_3 \left(n + 1\right)
+ c_4 \sum \limits_{y = 0}^{n} t_y \left(k + 1 \right)
+ c_5 \sum \limits_{y = 0}^{n} \sum \limits_{x = 0}^{k} t_y t_x\\
& \quad + c_6 \sum \limits_{y = 0}^{n} \sum \limits_{x = 0}^{k} t_y t_x
+ c_7 \sum \limits_{y = 0}^{n} \sum \limits_{x = 0}^{k} t_y t_x
+ c_9 \sum \limits_{y = 0}^{n} t_y \nonumber \\
\label{eq:linedetection-analyze3}
T(I)& =
c_1
+ c_2
+ c_3 \left(n + 1\right)
+ c_4 \left[n \left(k + 1 \right)\right]
+ c_5 n k
+ c_6 n k
+ c_7 n k
+ c_9 n\\
\label{eq:linedetection-analyze4}
T(I)& = c_1 + c_2 + c_3 + \left(c_3 + c_4 + c_9\right) n + \left(c_4 + c_5 + c_6 + c_7\right) n k\\
\label{eq:linedetection-analyze5}
T(I)& = \Theta(nk)
\end{align}
\end{subequations}

Das Verfahren zur Bestimmung der Edgels (\autoref{alg:findedgels-horizontal} und \autoref{alg:findedgels-vertical})
 benötigt das monochrome Bildsignal $I_m$, sowie die Position der oberen linken Ecke der Region, die durch oben $t$ und
 links $l$ definiert ist. Der Zeiger $E$ wird zur Speicherung der gefundenen \glspl{edgel} verwendet.

\input{alg/analyse-hirzer/findedgels}

Zeile \ref{alg:findedgels-horizontal-scanlinestart}--\ref{alg:findedgels-horizontal-scanlineend} ist für den Aufbau der
 horizontalen Scanlines verantwortlich. Die Überprüfung sorgt dafür, dass die Scanlines bis zum Ende der Region im
 Abstand von $5$ Pixeln untersucht werden. Nach der Initialisierung der Variablen wird in der Schleife von
 Zeile~\ref{alg:findedgels-horizontal-loopstart}--\ref{alg:findedgels-horizontal-loopend} jeder Pixel auf der Scanline
 untersucht. Zuerst wird in Zeile \ref{alg:findedgels-horizontal-convolute} die Faltung mit einem Gauß-Kernel
 vorgenommen (Vgl. \autoref{alg:convolutekernel-horizontal}, S. \pageref{alg:convolutekernel-horizontal}). Der Test
 in Zeile \ref{alg:findedgels-horizontal-foundedgel} überprüft anschließend das Ergebnis der Faltung. Wenn der
 Schwellwert nicht überschritten wird, gibt es keinen genügend großen Anstieg des Gradienten und das Ergebnis wird auf
 $0$ gesetzt. Wird der Schwellwert überschritten, handelt es sich um einen Edgel und das Ergebnis wird in den
 Bedingungen von Zeile \ref{alg:findedgels-horizontal-maxima} weiter untersucht, ob es sich um ein lokales Maximum
 handelt. Ein lokales Maximum bedeutet, dass ein Edgel einen größeren Gradienten besitzt als seine beiden Nachbarn.

Die Bedingung in Zeile \ref{alg:findedgels-horizontal-maxima} wird bei der ersten Überprüfung immer fehlschlagen.
 Dadurch wird sichergestellt, dass kein Maximum an den Rändern existiert, da hier nicht genügend Nachbarn vorhanden sind
 um eine verlässliche Aussage zu treffen. Zeile \ref{alg:findedgels-horizontal-copy-prev1} und
 Zeile \ref{alg:findedgels-horizontal-copy-edgel} kopieren die Werte für den nächsten Durchlauf. Durch das kopieren der
 Werte werden die Nachbarn für den nächsten Durchlauf um eine Position weiterverschoben. Nur bei einem lokalen Maximum
 (Zeile \ref{alg:findedgels-horizontal-maxima}--\ref{alg:findedgels-horizontal-maxima-end}) wird die Position des
 Edgels gespeichert (Vgl. \autoref{alg:vectorsetcoordinate}), und seine Orientierung
 (Vlg. \autoref{alg:sobel}, S. \pageref{alg:sobel}) berechnet. Der Edgel wird mit \autoref{alg:edgelpool-addedgel} in
 einem Speicherblock zu weiteren Verarbeitung gespeichert. Sind alle Pixel auf einer Scanline untersucht, wird in Zeile
 \ref{alg:findedgels-horizontal-increment} die nächste Scanline ausgewählt. Das Verfahren wird solange wiederholt, bis
 alle Scanlines innerhalb der Region untersucht wurden. \autoref{alg:findedgels-vertical} untersucht die vertikalen
 Scanlines in Zeile \ref{alg:findedgels-vertical-scanlinestart}--\ref{alg:findedgels-vertical-scanlineend} analog zu
 \autoref{alg:findedgels-horizontal} Zeile
 \ref{alg:findedgels-horizontal-scanlinestart}--\ref{alg:findedgels-horizontal-scanlineend}.

\autoref{alg:convolutekernel-horizontal} und \autoref{alg:convolutekernel-vertical} berechnen den Gradienten durch Faltung mit dem Gauß-Kernel
$\left( \begin{smallmatrix}
-3& -5& 0& 5& 3
\end{smallmatrix} \right)$
 auf der horizontalen und vertikalen Scanline. Als Parameter benötigt der Algorithmus den Zeiger des monochromen
 Bildsignals $I_m$, die Position des Pixels ($x$ und $y$), sowie die Breite $w$ und Höhe $h$ von $I_m$. In Zeile
 \ref{alg:convolutekernel-horizontal-readstart}--\ref{alg:convolutekernel-horizontal-readend} werden durch die
 Funktion \textproc{getpixel} (Vgl. \autoref{alg:getpixel}, S. \pageref{alg:getpixel}) die benötigten Pixelwerte
 ausgelesen und den Variablen zugewiesen. Im Anschluss werden die Werte mit dem Gauß-Kernel
$\left( \begin{smallmatrix}
-3& -5& 0& 5& 3
\end{smallmatrix} \right)$
berechnet um den Gradienten zu bestimmen.

\input{alg/analyse-hirzer/convolutekernel}

Bei genauer Betrachtung von \autoref{alg:convolutekernel-horizontal} und \autoref{alg:convolutekernel-vertical}
 fällt auf, dass der Wert $p_3$ in der Berechnung nicht vorkommt. Dies ist darauf zurückzuführen, dass der Gauß-Kernel
 an der dritten Stelle mit $0$ definiert ist. Somit kann die Multiplikation vernachlässigt werden. Die Laufzeit von
 \autoref{alg:convolutekernel-horizontal} und \autoref{alg:convolutekernel-vertical} ist konstant.

In \autoref{alg:gradientintensity} wird mittels Faltung die Orientierung eines \glspl{edgel} bestimmt. Als
 Eingabeparameter wird das monochrome Bildsignal $I_m$, dessen Breite $w$ und Höhe $h$, sowie die Position des
 \glspl{edgel} ($x,y$) benötigt.

\input{alg/analyse-hirzer/gradientintensity}

In Zeile \ref{alg:gradientintensity-readstart}--\ref{alg:gradientintensity-readend} werden die Pixelwerte ausgelesen
 und den Variablen zugewiesen. In
 Zeile\ref{alg:gradientintensity-convolutestart}--\ref{alg:gradientintensity-convoluteend} erfolgt die Faltung mit dem
 Sobel-Operator\footcite[Vgl.][S.~120--123]{burger05}, dessen Filter

\begin{subequations}
\begin{align}
	H_x =&
	\begin{pmatrix}
		1& 0& -1\\
		2& 0& -2\\
		1& 0& -1
	\end{pmatrix}
\end{align}
\begin{align}
	H_y =&
	\begin{pmatrix}
		1& 2& 1\\
		0& 0& 0\\
		-1& -2& -1
	\end{pmatrix}
\end{align}
\end{subequations}

den Gradienten $G_x$ und $G_y$ bestimmen. Wie in \autoref{alg:convolutekernel-horizontal} werden Multiplikationen von
 $0$-Werten des Filters vernachlässigt. Mit

\begin{equation}
	\label{eq:orientation}
	\Phi(x,y) = \arctan{\left(\tfrac{G_y}{G_x}\right)}
\end{equation}

kann die Orientierung berechnet werden. $G_x$ und $G_y$ werden mit \autoref{alg:vectorsetcoordinate} als
 \textproc{vector} gespeichert und normalisiert
 (Zeile \ref{alg:gradientintensity-vector-start}--\ref{alg:gradientintensity-vector-end}). Die Laufzeit von
 \autoref{alg:gradientintensity} ist konstant.

\input{alg/analyse-hirzer/findlinesegments}
