\citeauthor{clarke96} verwenden in ihrem Verfahren ein monochromes Bildsignal $I_m$\footcite[Vgl.][S.~417]{clarke96}.
 Die Konvertierung des Bildsignals $I$ von YCbCr in $I_m$ erfolgt durch \autoref{alg:convertmonochrome}. Ein YCbCr
 Signal besteht aus einem Luminanz Kanal $Y$ und den Chroma Abweichungen $Cb$ und $Cr$. Um ein monochromes Signal $I_m$
 zu erstellen, muss der Luminanz Kanal ausgelesen und in einen Puffer kopiert werden.
\input{alg/analyse-hirzer/convertmonochrome}
Der Algorithmus verwendet als Parameter das Bildsignal $I$ und einen Zeiger $I_m$ auf einen Puffer für das monochrome
 Signal. Der Monochrompuffer $I_m$ ist ein Array mit fester Größe, das beim initialisieren einmalig angelegt wird und
 danach wiederverwendet werden kann. In Zeile~\ref{alg:convertmonochrome-baseaddress} wird die Adresse des
 Luminanz-Kanals $Y$ ausgelesen. Die Funktionen \textproc{width} und \textproc{height} liefern die Breite und Höhe des
 Signals in Pixeln, mit denen die Länge der Daten berechnet wird. Anschließend werden die Daten in den Puffer kopiert.
 Die Konvertierung des Bildsignals ist ein Verarbeitungsschritt der vor dem Verfahren von \citeauthor{clarke96}
 durchgeführt wird und wird nur der Vollständigkeit erwähnt.

Um auf \gls{pixel} zugreifen zu können, wird \autoref{alg:getpixel} verwendet.
\input{alg/analyse-hirzer/getpixel}
Es wird der Puffer $I_m$ als Zeiger übergeben und die Position $x$ und $y$ des gewünschten Pixels. $w$ und $h$
 entsprechen der Breite und Höhe von $I_m$. Zeile~\ref{alg:getpixel-startcheck} bis Zeile~\ref{alg:getpixel-stopcheck}
 sorgen dafür, dass keine Werte außerhalb des Puffers gelesen werden können. Dies ist für die Randbehandlung bei
 Faltungsoperationen (Vgl. \autoref{sub:filter}) wichtig und wiederholt den \gls{pixel}. Die Laufzeitfunktion von
 \autoref{alg:getpixel} ist im schlimmsten Fall $T(n) = 13$ und somit konstant.

Der Algorithmus von \citeauthor{clarke96} ist in \autoref{alg:linedetection-clarke} aufgeführt und benötigt das
 monochrome Bildsignal $I_m$.
\input{alg/analyse-hirzer/linedetection-clarke}
In der doppelten Schleife in Zeile \ref{alg:linedetection-clarke-start} bis \ref{alg:linedetection-clarke-end} wird
 $I_m$ in Regionen der Größe $40 \times 40$ \gls{pixel} unterteilt. Die globalen Variablen $\mathit{imageWidth}$ und
 $\mathit{imageHeight}$ enthalten die Breite und Höhe des Bildsignals $I_m$. Die Regionengröße von $40$ Pixeln ist
 in der globalen Variable $\mathit{regionSize}$ gespeichert. In \citeauthor{clarke96}\footcite{clarke96} sind keine
 Hintergrundinformationen zu der Größe einer Region angegeben. Betrachtet man $640 \bmod 40 = 0$ und $480 \bmod 40 = 0$
 ist ersichtlich, dass die Größe der Region und der Aufteilung des Bildsignals in Zusammenhang steht. In Zeile
 \ref{alg:linedetection-clarke-call-start}--\ref{alg:linedetection-clarke-call-end} werden zuerst \gls{edgel}
 ermittelt, um im Anschluss daraus Liniensegmente zu erstellen. Wenn für eine Region Liniensegmente erstellt und
 gespeichert wurden, wird der Speicherblock der \gls{edgel} und Liniensegmente in Zeile
 \ref{alg:linedetection-clarke-reset-start}--\ref{alg:linedetection-clarke-reset-end} gelöscht.

Das Verfahren zur Bestimmung der Edgel (\autoref{alg:findedgels-horizontal} und \autoref{alg:findedgels-vertical})
 benötigt das monochrome Bildsignal $I_m$, sowie die Position der oberen linken Ecke der Region, die durch oben $t$ und
 links $l$ definiert ist.
\input{alg/analyse-hirzer/findedgelsclarke1}
Der Zeiger $E$ wird zur Speicherung der gefundenen \gls{edgel} verwendet. Zeile
 \ref{alg:findedgels-horizontal-scanlinestart}--\ref{alg:findedgels-horizontal-scanlineend} ist für den Aufbau der
 horizontalen Scanlines verantwortlich. Die Überprüfung sorgt dafür, dass die Scanlines bis zum Ende der Region im
 Abstand von $5$ Pixeln untersucht werden. Nach der Initialisierung der Variablen wird in der Schleife von
 Zeile~\ref{alg:findedgels-horizontal-loopstart}--\ref{alg:findedgels-horizontal-loopend} jedes Pixel auf der Scanline
 untersucht. Zuerst wird in Zeile \ref{alg:findedgels-horizontal-convolute} die Faltung mit einem Gauß-Kernel
 vorgenommen (Vgl. \autoref{alg:convolutekernel-horizontal}, S. \pageref{alg:convolutekernel-horizontal}). Der Test
 in Zeile \ref{alg:findedgels-horizontal-foundedgel} überprüft anschließend das Ergebnis der Faltung. Wenn der
 Schwellwert nicht überschritten wird, gibt es keinen genügend großen Anstieg des Gradienten und das Ergebnis wird auf
 $0$ gesetzt. Wird der Schwellwert überschritten, handelt es sich um ein Edgel und das Ergebnis wird in den
 Bedingungen von Zeile \ref{alg:findedgels-horizontal-maxima} weiter untersucht, ob es sich um ein lokales Maximum
 handelt. Ein lokales Maximum bedeutet, dass ein Edgel einen größeren Gradienten besitzt als seine beiden Nachbarn. Die
 Bedingung in Zeile \ref{alg:findedgels-horizontal-maxima} wird bei der ersten Überprüfung immer fehlschlagen.
 Dadurch wird sichergestellt, dass kein Maximum an den Rändern existiert, da hier nicht genügend Nachbarn vorhanden sind
 um eine verlässliche Aussage zu treffen. Zeile \ref{alg:findedgels-horizontal-copy-prev1} und
 Zeile \ref{alg:findedgels-horizontal-copy-edgel} kopieren die Werte für den nächsten Durchlauf. Durch das kopieren der
 Werte werden die Nachbarn für den nächsten Durchlauf um eine Position weiter verschoben. Nur bei einem lokalen Maximum
 (Zeile \ref{alg:findedgels-horizontal-maxima}--\ref{alg:findedgels-horizontal-maxima-end}) wird die Position des
 Edgels gespeichert (Vgl. \autoref{alg:vectorsetcoordinate}, S. \pageref{alg:vectorsetcoordinate}), und seine
 Orientierung berechnet (Vgl. \autoref{alg:gradientintensity}, S. \pageref{alg:gradientintensity}). Das Edgel wird mit
 \textproc{addEdgel} (\autoref{alg:edgelpool-addedgel}, S. \pageref{alg:edgelpool-addedgel}) in einem Speicherblock zu
 weiteren Verarbeitung gespeichert. Sind alle Pixel auf einer Scanline untersucht, wird in Zeile
 \ref{alg:findedgels-horizontal-increment} die nächste Scanline ausgewählt. Das Verfahren wird solange wiederholt, bis
 alle Scanlines innerhalb der Region untersucht wurden. \autoref{alg:findedgels-vertical} untersucht die vertikalen
 Scanlines in Zeile \ref{alg:findedgels-vertical-scanlinestart}--\ref{alg:findedgels-vertical-scanlineend} analog zu
 \autoref{alg:findedgels-horizontal} Zeile
 \ref{alg:findedgels-horizontal-scanlinestart}--\ref{alg:findedgels-horizontal-scanlineend}.
\input{alg/analyse-hirzer/findedgelsclarke2}

Die Laufzeitfunktion von \autoref{alg:findedgels-horizontal} ist in \autoref{eq:findedgels1} angegeben. Die Eingabemenge
 $\mathit{regionSize}$ wurde durch die Variable $r$ ersetzt. Die bereits vorgestellten Methoden
 \textproc{vectorSetCoordinate} (\autoref{alg:vectorsetcoordinate}) und \textproc{addEdgel}
 (\autoref{alg:edgelpool-addedgel}) haben eine konstante Laufzeit. Die Methoden \textproc{convoluteKernelX},
 \textproc{convoluteKernelY} und \textproc{gradientIntensity} haben ebenfalls eine konstante Laufzeit, die zu einem
 späteren Zeitpunkt bewiesen wird.
\input{eq/hirzer/findedgels1}
Die Wachstumsrate der Laufzeitfunktion $T(r) = \tfrac{1}{5} (12r^2 + 6r + 5) + \frac{4r^2}{5}\Theta(1)
 = \tfrac{1}{5} (16r^2 + 6r + 5)$, für $c_{1} = 16$, $c_{2} = 17$ und $r_{0} = 6$, ist $16r^2 + 6r = \Theta(r^2)$. Die
 Laufzeitfunktion von \autoref{alg:findedgels-vertical} ist in \autoref{eq:findedgels2} angegeben.
\input{eq/hirzer/findedgels2}
Die Wachstumsrate der Laufzeitfunktion $T(r) = \tfrac{1}{5} (12r^2 + 6r + 5) + \frac{4r^2}{5}\Theta(1)
 = \tfrac{1}{5} (16r^2 + 6r + 5)$, für für $c_{1} = 16$, $c_{2} = 17$ und $r_{0} = 6$, ist $16r^2 + 6r = \Theta(r^2)$
 und entspricht der Wachstumsrate von \autoref{alg:findedgels-horizontal}. Damit ist die Wachstumsrate von \textproc{findEdgels} $\Theta(r^2) + \Theta(r^2) = \Theta(r^2)$.

\textproc{convoluteKernelX} (\autoref{alg:convolutekernel-horizontal}) und \textproc{convoluteKernelY}
 (\autoref{alg:convolutekernel-vertical}) berechnen den Gradienten durch Faltung mit dem Gauß-Kernel
$\left( \begin{smallmatrix}
-3& -5& 0& 5& 3
\end{smallmatrix} \right)$
auf der horizontalen und vertikalen Scanline. Als Parameter benötigt der Algorithmus den Zeiger des monochromen
 Bildsignals $I_m$, die Position des Pixels ($x$ und $y$), sowie die Breite $w$ und Höhe $h$ von $I_m$. In Zeile
 \ref{alg:convolutekernel-horizontal-readstart}--\ref{alg:convolutekernel-horizontal-readend} werden durch die
 Funktion \textproc{getpixel} (Vgl. \autoref{alg:getpixel}, S. \pageref{alg:getpixel}) die benötigten Werte
 ausgelesen und den Variablen zugewiesen. Im Anschluss werden die Werte mit dem Gauß-Kernel
$\left( \begin{smallmatrix}
-3& -5& 0& 5& 3
\end{smallmatrix} \right)$
berechnet um den Gradienten zu bestimmen.
\input{alg/analyse-hirzer/convolutekernelx}
Bei genauer Betrachtung von \autoref{alg:convolutekernel-horizontal} und \autoref{alg:convolutekernel-vertical}
 fällt auf, dass der Wert $p_3$ in der Berechnung nicht vorkommt.
\input{alg/analyse-hirzer/convolutekernely}
Dies ist darauf zurückzuführen, dass der Gauß-Kernel an der dritten Stelle mit $0$ definiert ist. Somit kann die
 Multiplikation vernachlässigt werden. Die Laufzeitfunktion von \autoref{alg:convolutekernel-horizontal} und
 \autoref{alg:convolutekernel-vertical} ist $T(n) = 4 \cdot \Theta(1) + 22$ und somit konstant.

In \autoref{alg:gradientintensity} wird mittels Faltung die Orientierung eines \glspl{edgel} bestimmt. Als
 Eingabeparameter wird das monochrome Bildsignal $I_m$, dessen Breite $w$ und Höhe $h$, sowie die Position des
 \glspl{edgel} ($x,y$) benötigt.
\input{alg/analyse-hirzer/gradientintensity}
In Zeile \ref{alg:gradientintensity-readstart}--\ref{alg:gradientintensity-readend} werden die Werte ausgelesen
 und den Variablen zugewiesen. In Zeile
 \ref{alg:gradientintensity-convolutestart}--\ref{alg:gradientintensity-convoluteend} erfolgt die Faltung mit dem
 Sobel-Operator\footcite[Vgl.][S.~120--123]{burger05}, dessen Filter
\begin{subequations}
\begin{align}
	H_x =&
	\begin{pmatrix}
		1& 0& -1\\
		2& 0& -2\\
		1& 0& -1
	\end{pmatrix}
\end{align}
\begin{align}
	H_y =&
	\begin{pmatrix}
		1& 2& 1\\
		0& 0& 0\\
		-1& -2& -1
	\end{pmatrix}
\end{align}
\end{subequations}
den Gradienten $G_x$ und $G_y$ bestimmen. Wie in \autoref{alg:convolutekernel-horizontal} werden Multiplikationen von
 $0$-Werten des Filters vernachlässigt. Mit
\begin{equation}
	\label{eq:orientation}
	\Phi(x,y) = \arctan{\left(\tfrac{G_y}{G_x}\right)}
\end{equation}
kann die Orientierung berechnet werden. $G_x$ und $G_y$ werden mit \autoref{alg:vectorsetcoordinate} als
 \textproc{vector} gespeichert und normalisiert
 (Zeile \ref{alg:gradientintensity-vector-start}--\ref{alg:gradientintensity-vector-end}). Die Laufzeitfunktion von
 \autoref{alg:gradientintensity} ist $T(n) = 14 \cdot \Theta(1) + 61$. Die Wachstumsrate ist konstant.

Um aus den gefundenen Edgeln Liniensegmente zu erzeugen, wird \autoref{alg:findlinesegments1} verwendet. Das
 Verfahren benötigt den Speicherblock $E$, in dem die \gls{edgel} vorliegen, und den Speicherblock $L$, der zur
 Speicherung der gefundenen Liniensegmente dient.
\input{alg/analyse-hirzer/findlinesegments-1}
In Zeile \ref{alg:findlinesegments1-init-start}--\ref{alg:findlinesegments1-init-end} wird die Variable
 $\mathit{presentLine}$ initialisiert. Diese Variable enthält das zu speichernde Liniensegment im Verfahren.
 Die Zählvariable $\mathit{edgelsInRegion}$ wird mit $0$ initialisiert und speichert die Anzahl der \gls{edgel} in
 einer Region. In der Schleife von Zeile \ref{alg:findlinesegments1-loop-start} bis Zeile
 \ref{alg:findlinesegments1-loop-end} wird das RANSAC-Verfahren wiederholt, solange das zu untersuchende Liniensegment
 genügend Unterstützung durch \gls{edgel} besitzt und genügend \gls{edgel} in der Region vorhanden sind. Die Anzahl der
 unterstützenden \gls{edgel} wird in Zeile \ref{alg:findlinesegments1-clearsupport} für jeden Durchlauf gelöscht.
 Danach wird in Zeile \ref{alg:findlinesegments1-line-start}--\ref{alg:findlinesegments1-line-end} ein zufälliges
 Liniensegment in der Region erstellt und untersucht
 (Vgl. \autoref{alg:findlinesegments2}--\autoref{alg:findlinesegments4}). Die Erstellung eines Liniensegments wird
 mehrmals wiederholt, um das Liniensegment mit den meisten Unterstützungsedgeln zu finden. In Zeile
 \ref{alg:findlinesegments1-hasenoughsupport} wird die Anzahl der unterstützenden \gls{edgel} mit der Anzahl der
 benötigten \gls{edgel} verglichen. Nur wenn genügend \gls{edgel} das Liniensegment unterstützen, wird in
 \autoref{alg:findlinesegments6}--\autoref{alg:findlinesegments7} das Verfahren fortgesetzt und die
 Unterstützungsedgel aus dem Speicherblock $E$ entfernt.

In \autoref{alg:findlinesegments2} wird die Initialisierung der Variablen vorgenommen, die zur Erstellung eines
 Liniensegments benötigt werden.
\input{alg/analyse-hirzer/findlinesegments-2}
Die Variablen $\mathit{start}$ und $\mathit{end}$ werden als Indizes für \gls{edgel} benutzt. $\mathit{first}$ ist das
 Startedgel und $\mathit{last}$ das Endedgel des Liniensegments. Die Variable $\mathit{maxIteration}$ gibt die maximale
 Anzahl der Iterationen an, die $\mathit{iterator}$ durchlaufen kann. In $\mathit{numberOfEdgels}$ wird die Anzahl der
 \gls{edgel} in $E$ gespeichert. Die Laufzeitfunktion der Initialisierung ist $T(n) = 7 + \Theta(1)$ und somit
  konstant.

Die Auswahl eines Liniensegments erfolgt mit \autoref{alg:findlinesegments3}. Zeile
 \ref{alg:findlinesegments3-loop-start}--\ref{alg:findlinesegments3-loop-end} ist dafür verantwortlich, solange nach
 einem Liniensegment zu suchen, bis das erste und letzte \gls{edgel} sich unterscheiden oder ihre Orientierung
 zueinander kompatibel ist.
\input{alg/analyse-hirzer/findlinesegments-3}
Als letzte Bedingung muss die Anzahl der Iterationen unterhalb des festgelegten Schwellwerts $\mathit{maxIteration}$
 bleiben. In Zeile \ref{alg:findlinesegments3-first} und Zeile \ref{alg:findlinesegments3-last} werden zufällig zwei
 Indizes aus der Menge der vorhandenen \gls{edgel} errechnet. Diese werden in Zeile
 \ref{alg:findlinesegments3-start}--\ref{alg:findlinesegments3-end} verwendet, um die beiden \gls{edgel}
 $\mathit{start}$ und $\mathit{end}$ auszuwählen. Der Iterator wird anschließend in Zeile
 \ref{alg:findlinesegments3-inc} inkrementiert.

Die Laufzeit der Funktion \textproc{rand} wurde durch eine Regressionsanalyse mit $300$ Testdaten ermittelt. Wenn diese
 Daten in der grafischen Darstellung in \autoref{fig:regression-rand} betrachtet werden, ist ersichtlich, dass keine
 lineare Abhängigkeit besteht.
\begin{figure}[!ht]
	\centering
	\input{resources/Regression-rand.pdf_tex}
	\caption{Regressionsanalyse von \textproc{rand} mit $300$ Datenpunkte. Der Mittelwert der Daten ist als grüne Linie
	 eingezeichnet und der Median der Daten als rote Linie.}
	\label{fig:regression-rand}
\end{figure}
Dies ist auch dadurch begründet, dass \textproc{rand} keine Eingabedaten benötigt\footcite[Vgl.][]{rand}. Somit
 entspricht die Laufzeit von \textproc{rand} $T(n) = \Theta(1)$ und ist demnach konstant. Die Laufzeit von
 \textproc{getEdgel} (\autoref{alg:edgelpool-getedgel}) ist ebenfalls konstant. Die Laufzeit von
 \autoref{alg:findlinesegments3} ist somit abhängig von der Anzahl der Wiederholungen in Zeile
 \ref{alg:findlinesegments3-loop-end}. Im schlechtesten Fall wird \autoref{alg:findlinesegments3}
 $\mathit{maxIteration} = 64$ mal ausgeführt. Die Laufzeitfunktion ist in \autoref{eq:findlinesegments1} angegeben. Die
 Wachstumsrate ist konstant.
\input{eq/hirzer/findlinesegments1}

Wenn in \autoref{alg:findlinesegments3} ein Liniensegment erstellt wurde, werden in \autoref{alg:findlinesegments4} die
 \gls{edgel} zur Unterstüztung der Hypothese hinzugefügt.
\input{alg/analyse-hirzer/findlinesegments-4}
Dazu wird in Zeile \ref{alg:findlinesegments4-isbelowmax} überprüft, ob die maximale Anzahl der Iterationen nicht
 überschritten wurde. Falls dem so ist wird \autoref{alg:findlinesegments4} nicht weiter ausgeführt und die Laufzeit
 wäre $T_{best}(n) = \Theta(1)$. Andernfalls wird in Zeile
 \ref{alg:findlinesegments4-init-start}--\ref{alg:findlinesegments4-init-end} die Variable $\mathit{segment}$ zur
 Speicherung des Liniensegments vorbereitet und das Start- und Endedgel, sowie die Orientierung zugewiesen. Die Anzahl
 der Unterstützungsedgel beträgt zu diesem Zeitpunkt noch $0$. In der Schleife in Zeile
 \ref{alg:findlinesegments4-loop-start}--\ref{alg:findlinesegments4-loop-end} werden die \gls{edgel} gezählt, die die
 Linienhypothese unterstützen. Dazu wird in Zeile \ref{alg:findlinesegments4-edgel} ein \gls{edgel} ausgewählt und in
 Zeile \ref{alg:findlinesegments4-isedgelnearline} untersucht, ob der Abstand zur Linie klein genug ist. Wenn nicht,
 wird in Zeile \ref{alg:findlinesegments4-inc} die Laufvariable $j$ inkrementiert und das nächste \gls{edgel}
 ausgewählt. Die Wiederholung der Schleife ist von $\mathit{numberOfEdgels}$ abhängig, die von \textproc{findEdgels}
 gefunden wurden. Die ersten beiden \gls{pixel} können durch die Bedingung in Zeile
 \ref{alg:findedgels-horizontal-maxima} (\autoref{alg:findedgels-horizontal}) nicht zur Untersuchung verwendet werden.
 Zusätzlich muss ein lokales Maximum vorliegen, sodass in einer Scanline maximal
 $\bigl\lfloor\tfrac{\mathit{regionSize}-2}{2}\bigr\rfloor$ \gls{edgel} gefunden werden können. Somit können in einer
 Region maximal $\tfrac{1}{5}(\mathit{regionSize}^2 -2\mathit{regionSize}) = n$ \gls{edgel} vorkommen. Dies ist der
 schlechteste Fall der Wiederholung. Wenn ein \gls{edgel} nahe genug an dem Liniensegment liegt, wird es in Zeile
 \ref{alg:findlinesegments4-addedgel} dem Liniensegment hinzugefügt und die Anzahl der Unterstützungsedgel wird in
 Zeile \ref{alg:findlinesegments4-count} erhöht. Nachdem alle \gls{edgel} untersucht wurden, wird in Zeile
 \ref{alg:findlinesegments4-hasmoresupport} überprüft, ob die Anzahl der \gls{edgel} des Liniensegments
 $\mathit{segment}$ größer ist als die Anzahl der \gls{edgel} in $\mathit{presentLine}$. Im Falle, dass
 $\mathit{segment}$ mehr Unterstützungsedgel besitzt, wird das Liniensegment in $\mathit{presentLine}$ gespeichert.
 Durch die Wiederholung in \autoref{alg:findlinesegments1} wird sichergestellt, dass das Liniensegment mit der größten
 Unterstützung ausgewählt wird. Die Laufzeitfunktion ist in \autoref{eq:findlinesegments-2} aufgeführt.
\input{eq/hirzer/findlinesegments2}
% Durch Rücksubstitution von $n = \tfrac{1}{5}(r^2 - 2r)$ in \autoref{eq:findlinesegments-2-4} ist die Wachstumsrate
% $\tfrac{11r^2}{5} - \frac{22r}{5} = \Theta(r^2)$, für $c_{1}=2$, $c_{2}=3$ und $r_{0} = 22$.
Die Wachstumsrate des Verfahrens ist $11n + 22 = \Theta(n)$, für $c_{1} = 10$, $c_{2} = 11$ und $n_{0} = 1$.

Nachdem ein Liniensegment mit genügend Unterstützung ausgewählt wurde, kann mit \autoref{alg:findlinesegments5} die
 Start- und Endposition des Liniensegments bestimmt werden.
\input{alg/analyse-hirzer/findlinesegments-5}
Da ein Liniensegment aus zwei zufällig ausgewählten Edgeln besteht, können diese \gls{edgel} und die
 tatsächlichen Start- und Endpunkte voneinander abweichen (Vgl. \autoref{fig:endedgel})
\begin{figure}[!ht]
	\centering
	\input{resources/Endedgel.pdf_tex}
	\caption{Bestimmung der Linienenden. Die grün markierten Edgel wurden zur Linienerkennung verwendet.
	 Das Verfahren ermittelt nun die rot markierten Edgel als die tatsächlichen Linienenden.}
	\label{fig:endedgel}
\end{figure}
In Zeile
 \ref{alg:findlinesegments5-start}--\ref{alg:findlinesegments5-end} wird dazu die Variable $\mathit{start}$ mit einem
 kleinen Wert, und die Variable $\mathit{end}$ mit einem großen Wert, initialisiert. Die Steigung des Liniensegments
 und die Orthogonale werden in Zeile \ref{alg:findlinesegments5-slope-start}--\ref{alg:findlinesegments5-slope-end}
 berechnet. In Zeile \ref{alg:findlinesegments5-isxsmaller} wird geprüft, ob der Absolutwert der Steigung an Punkt $x$
 kleiner ist als der Punkt $y$. Falls dem so ist, wird in Zeile
 \ref{alg:findlinesegments5-newstart-start}--\ref{alg:findlinesegments5-newstart-end} ein neuer Start- und Endpunkt
 gesucht, indem die $y$-Koordinate aller Unterstützungsedgel des Liniensegments verglichen werden. Die Kosten von
 \textproc{findLineSegments} sind in \autoref{alg:findlinesegments5} aufgelistet. Der Algorithmus ist abhängig von
 $[0,\mathit{presentLine.supportCount}) = n$ \gls{edgel}. Die Laufzeitfunktion ist in \autoref{eq:findlinesegments-3}
 angegeben.
\input{eq/hirzer/findlinesegments3}
Die Wachstumsrate, für $c_{1} = 20$, $c_{2} = 21$ und $n_{0} = 1$, ist $21n + 20 = \Theta(n)$.

Wenn in \autoref{alg:findlinesegments5} in Zeile \ref{alg:findlinesegments5-isxsmaller} der Absolutwert der Steigung an
 Punkt $x$ größer ist als an Punkt $y$, wird in \autoref{alg:findlinesegments6} in Zeile
 \ref{alg:findlinesegments6-newstart-start}--\ref{alg:findlinesegments6-newstart-end} ein neuer Start- und Endpunkt
 gesucht, indem die $x$-Koordinate aller \gls{edgel} des Liniensegments untersucht und verglichen werden.
\input{alg/analyse-hirzer/findlinesegments-6}
Am Ende von \autoref{alg:findlinesegments6} ist in $\mathit{presentLine}$ ein neuer Start- und Endpunkt gespeichert.
 Auch hier ist die Laufzeit des Algorithmus abhängig von $[0,\mathit{presentLine.supportCount}) = n$. Die
 Laufzeitfunktion von \autoref{alg:findlinesegments6} ist in \autoref{eq:findlinesegments-4} aufgeführt.
\input{eq/hirzer/findlinesegments4}
Wie bei \autoref{alg:findlinesegments5} auch, entspricht die Wachstumsrate $21n + 1 = \Theta(n)$, für
 $c_{1} = 20$, $c_{2} = 21$ und $n_{0} = 1$. Die Wachstumsrate von \autoref{alg:findlinesegments5} und
 \autoref{alg:findlinesegments6} ist somit $\Theta(n) + \Theta(n) = \Theta(n)$.

In \autoref{alg:findlinesegments7} wird nun geprüft, ob der Start- und Endpunkt vertauscht ist. Dazu wird der Winkel
 zwischen dem Liniensegment und seiner Orthogonalen gebildet.
\input{alg/analyse-hirzer/findlinesegments-7}
Wenn der Winkel kleiner als $0$ ist, werden Start- und Endpunkt in Zeile
 \ref{alg:findlinesegments7-newstart-start}--\ref{alg:findlinesegments7-newstart-end} getauscht. Im Anschluss daran,
 wird in Zeile \ref{alg:findlinesegments7-save-start}--\ref{alg:findlinesegments7-save-end} die Orientierung des
 Liniensegments berechnet und gespeichert. Danach wird das Liniensegment in Zeile
 \ref{alg:findlinesegments7-addtomempool} in den Speicherblock $L$ hinterlegt. Jetzt müssen alle Unterstützungsedgel
 des Liniensegments in Zeile \ref{alg:findlinesegments7-removeedgel-start}--\ref{alg:findlinesegments7-removeedgel-end}
 aus dem Speicherblock $E$ entfernt werden. Das entfernen der Unterstützungsedgel bewirkt, dass entweder das
 RANSAC-Verfahren wiederholt werden kann ohne die gleichen \gls{edgel} erneut zu betrachten, oder, wenn nicht mehr
 genügend \gls{edgel} in der Region vorhanden sind, das Verfahren abzubrechen und die Linienerkennung zu beenden. Die
 Laufzeit von \autoref{alg:findlinesegments7} ist abhängig von dem Bereich $[0,\mathit{supportCount}) = n$. Die
 Kosten lassen sich zu \autoref{eq:findlinesegments-5} zusammen fassen. Die Methoden \textproc{vectorSubtract},
 \textproc{dotProduct}, \textproc{normalized} und \textproc{addLineSegment} haben eine konstante Laufzeit.
 \textproc{removeEdgel} hat eine Laufzeit von $T_{worst}(n)=\Theta(n)$, für $n = \mathit{numberOfEdgels}$. Die
 Laufzeitfunktion ist in \autoref{eq:findlinesegments-5} angegeben.
\input{eq/hirzer/findlinesegments5}
% Durch Substitution in \autoref{eq:findlinesegments-5-4} ist die Wachstumsrate des Verfahrens
% $20 - 2r + \tfrac{29}{25}r^2 - \tfrac{4}{25}r^3 + \tfrac{1}{25}r^4 = \Theta(r^4)$.
Die Wachstumsrate von \autoref{alg:findlinesegments7} ist $n^2 + 5n = \Theta(n^2)$, für $c_{1} = 1$, $c_{2} = 2$ und
 $n_{0} = 5$.

Die Laufzeit des RANSAC Verfahrens (\autoref{alg:findlinesegments1}) ist abhängig von der Anzahl der \gls{edgel} in
 Speicherblock $E$. Für die Analyse des Algorithmus in \autoref{alg:findlinesegments9} wird $n = $ Anzahl der
 \gls{edgel} verwendet.
\input{alg/analyse-hirzer/findlinesegments-9}
Die Methoden \textproc{vectorSubtract}, \textproc{dotProduct}, \textproc{normalized} und \textproc{addLineSegment}
 haben eine konstante Laufzeit. Die Abbruchbedingung der Schleife ist in Zeile \ref{alg:findlinesegments9-while} von
 \autoref{alg:findlinesegments9} angegeben. Sie besagt, dass die Anzahl der gefundenen Unterstützungsedgel größer sein
 muss als eine festgelegte Mindestanzahl. Zur Untersuchung wird die Mindestanzahl $\mathit{minEdgels} = 0$ festgelegt.
 Somit wird das Verfahren beendet, wenn ein Liniensegment keine Unterstützungsedgel enthält. Für die Untersuchung des
 schlechtesten Falls, muss die Anzahl der Wiederholungen der Schleife in Zeile
 \ref{alg:findlinesegments9-do}--\ref{alg:findlinesegments9-while} ermittelt werden. Zeile
 \ref{alg:findlinesegments9-hasmoresupport} überprüft, ob ein neues Liniensegment eine größere Anzahl von
 Unterstützungsedgeln besitzt, als ein bereits gefundenes Liniensegment. Bei der ersten Iteration der Schleife muss
 ein Liniensegment mit einem Unterstützungsedgel gefunden werden. Danach wird das Unterstützungsedgel und das Start-
 und Endedgel des Liniensegments von \autoref{alg:findlinesegments7} in Zeile
 \ref{alg:findlinesegments7-removeedgel-start}--\ref{alg:findlinesegments7-removeedgel-end} gelöscht. Bei der zweiten
 Iteration müssen mindestens zwei Unterstützungsedgel für ein Liniensegment gefunden werden. Danach werden vier
 \gls{edgel} entfernt. Somit kann durch
\begin{equation}
\label{eq:linesegments-nedgels}
\sum_{i=1}^{m} i + 2 = n
\end{equation}
die Anzahl $n$ der \gls{edgel} bestimmt werden, die für $m$ Iterationen benötigt werden. Durch Umformung von \autoref{eq:linesegments-nedgels} zu
\begin{equation}
\label{eq:linesegments-miteration}
m = \left\lfloor\frac{1}{2}(\sqrt{8n+25} - 5)\right\rfloor
\end{equation}
lässt sich die maximale Anzahl $m$ der Wiederholung ermitteln, die mit $n$ \gls{edgel} möglich sind. % Die maximal
%  mögliche Anzahl von \gls{edgel} ist $n = \frac{1}{5}(\mathit{regionSize}^2 - 2\mathit{regionSize})$.
Die Kosten der  Algorithmen sind zur Analyse des schlechtesten Falls in \autoref{alg:findlinesegments9} aufgeführt. Die
 Laufzeitfunktion des RANSAC Verfahrens ist in \autoref{eq:findlinesegments-7} angegeben.
\input{eq/hirzer/findlinesegments7}
Die Wachstumsrate ist $25mn^2 + 75mn + 108m = \Theta(mn^2)$, für $c_{1} = 11$, $c_{2} = 26$ und $n_{0} = 77$.

Mit den Laufzeiten der Algorithmen zur Linienerkennung nach \citeauthor{clarke96} kann nun die Laufzeit der Methode
 \textproc{lineDetection} (\autoref{alg:linedetection-clarke}) bestimmt werden. Die Kosten des Algorithmus sind in \autoref{alg:linedetection-clarke-analyse} aufgeführt , wobei $\mathit{regionSize}$ durch $r$ ersetzt wurde.
\input{alg/analyse-hirzer/linedetection-clarke2}
Die Eingabemenge von \autoref{alg:linedetection-clarke-analyse} ist $I_m$, wobei $I_m$ aus $\mathit{imageWidth} = w$
 und $\mathit{imageHeight} = h$ besteht. In der Schleifen in Zeile
 \ref{alg:linedetection-clarke-analyse-loopy-start}--\ref{alg:linedetection-clarke-analyse-loopy-end} und
 \ref{alg:linedetection-clarke-analyse-loopx-start}--\ref{alg:linedetection-clarke-analyse-loopx-end} werden die
 Regionen erstellt. Von \textproc{findEdgels} werden maximal $n$ \gls{edgel} gefunden, die \textproc{findLineSegments}
 als Eingabe dienen. Die Kosten des Algorithmus sind in \autoref{eq:linedetection-clarke-1} aufgeführt.
\input{eq/hirzer/linedetection-clarke}
Durch Substitution der Variablen $r = \mathit{regionSize} = 40$ in \autoref{eq:linedetection-clarke-4}, ist die
 Wachstumsrate $hwmn^2 + hw + h = O(hwmn^2)$.
