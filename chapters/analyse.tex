\section{Analyse} % (fold)
\label{sec:analyse}
\begin{comment}
	Detailierte Beschreibung der Algorithmen inkl. O-Notation (Nitty-Gritty Darstellung der Algos)
	1. ARToolKit
	2. ARToolKitPlus
	3. Zissermann/Clarke
	Analyse: Die auswertung nach den Kriterein aus Kap. Vorgehen OHNE WERTUNG! Nur die Daten erheben und auswerten.
\end{comment}

\subsection{Hirzer} % (fold)
\label{sub:hirzer}

\citeauthor{clarke96} verwenden in ihrem Verfahren ein monochromes Bildsignal $I_m$\footcite[Vgl.][S.~417]{clarke96}.
 Die Konvertierung des Bildsignals $I$ von YCbCr in $I_m$ erfolgt durch \autoref{alg:convertmonochrome}. Wie in
 \autoref{sub:farbräume} beschrieben, besteht ein YCbCr Signal aus einem Luminaz-Kanal $Y$ und den Chroma Abweichungen
 $Cb$ und $Cr$. Um ein monochromes Signal $I_m$ zu erstellen, muss der Luminanz Kanal ausgelesen und in einen Buffer
 kopiert werden.

\input{alg/convertmonochrome}

Der Algorithmus verwendet als Parameter das Bildsignal $I$ und einen Pointer $I_m$ auf einen Buffer für das monochrome
 Signal. Der Monochromebuffer $I_m$ ist ein Array mit fester Größe, das beim initialisieren einmalig angelegt wird und
 danach wiederverwendet werden kann. In Zeile \ref{alg:convertmonochrome-baseaddress} wird die Adresse des
 Luminanz-Kanals $Y$ ausgelesen. Die Funktionen \textproc{width} und \textproc{height} liefern die Breite und Höhe des
 Signals in Pixeln, mit denen die Länge der Daten berechnet wird. Anschließend werden die Daten in den Buffer kopiert.
 Die Laufzeit des Algorithmus entspricht $\Theta(1)$. (Vorsicht: Nur Zeile 5 verwendet keine Funktionen, deren Laufzeit
 dir nicht bekannt sind. baseaddress, width und height greifen evtl. auf metadaten zurück und wären damit ein einfacher
 lookup mit $\Theta(1)$. Dann wäre nur noch memcpy zu bestimmen, was im schlimmsten Fall $\Theta(n)$ wäre.)

Um auf \gls{pixel} zugreifen zu können, verwende ich \autoref{alg:getpixel}. Es wird der Buffer $I_m$ als Pointer
 übergeben und die Position $x$ und $y$ des gewünschten \gls{pixel}. $w$ und $h$ entsprechen der Breite und Höhe von
 $I_m$. Zeile \ref{alg:getpixel-startcheck} bis Zeile \ref{alg:getpixel-stopcheck} sorgen dafür, dass keine Werte
 außerhalb des Buffers gelesen werden können. Dies ist für die Randbehandlung bei Faltungsoperationen
 (Vgl. \autoref{sub:filter}) wichtig und wiederholt den \gls{pixel}.

\input{alg/getpixel}

Die Laufzeit von \autoref{alg:getpixel} ist im worst-case und im best-case konstant und somit $\Theta(1)$.

Der Algorithmus von \citeauthor{clarke96} ist in \autoref{alg:linedetection-analyze} aufgeführt. Zuerst wird die Breite
 $w$ und Höhe $h$ des Signals $I_m$ festgehalten. Die doppelte For-Schleife in Zeile
 \ref{alg:linedetection-analyze-start} bis \ref{alg:linedetection-analyze-end} unterteilt das Signal in Regionen der
 Größe $40 \times 40$ \gls{pixel}, indem die Koordinate der oberen linken Ecke berechnet wird.

\input{alg/linedetection-analyze}

In \citeauthor{clarke96} ist keine Angabe zu den Abmessungen der untersuchten Signale angegeben. Auch der Grund warum
 eine Region $40 \times 40$ \gls{pixel} gross sein muss, fehlt. Zur Analyse der Videosignale verwendeten
 \citeauthor{clarke96} einen Framegrabber 2000 der eine Auflösung von 640x480px schafft. Betrachtet man

$640 mod 40 = 0$ und $480 mod 40 = 0$

ist ersichtlich, dass die Größe der Region in der Aufteilung des Bildsignals in Zusammenhang steht.

Der \autoref{alg:linedetection-analyze} ist der zentrale Algorithmus von \citeauthor{clarke96}. Der Algorithmus
 ist verantwortlich für die Unterteilung des Bildsignals in Regionen von jeweils $40 \times 40$ \gls{pixel} (Vgl. Zeile
~\ref{alg:linedetection-analyze-start}--\ref{alg:linedetection-analyze-end}). Die Kosten des Algorithmus sind in \autoref{eq:linedetection-analyze1} aufgeführt. Um die Gleichung zu vereinfachen führe ich in \autoref{eq:linedetection-analyze2} $n = \tfrac{h}{40}$ und $k = \tfrac{w}{40}$ ein. Sowohl bei worst-case als auch bei best-case werden die Summen immer vollständig durchlaufen. Damit kann die Gleichung zu \autoref{eq:linedetection-analyze3} vereinfacht werden, was eine Laufzeit von $\Theta(nk)$ ergibt.

\begin{subequations}
\label{eq:linedetection-analyze}
\begin{multline}
	T(I) = c_1
	+ c_2
	+ c_3 \left(\frac{h}{40} + 1\right)
	+ c_4 \sum \limits_{y = 0}^{\frac{h}{40}} t_y \left(\frac{w}{40} + 1 \right)
	+ c_5 \sum \limits_{y = 0}^{\frac{h}{40}} \sum \limits_{x = 0}^{\frac{w}{40}} t_y t_x\\
	+ c_6 \sum \limits_{y = 0}^{\frac{h}{40}} \sum \limits_{x = 0}^{\frac{w}{40}} t_y t_x
	+ c_7 \sum \limits_{y = 0}^{\frac{h}{40}} \sum \limits_{x = 0}^{\frac{w}{40}} t_y t_x
	+ c_9 \sum \limits_{y = 0}^{\frac{h}{40}} t_y
	\label{eq:linedetection-analyze1}
\end{multline}
\begin{multline}
	T(I) = c_1
	+ c_2
	+ c_3 \left(n + 1\right)
	+ c_4 \sum \limits_{y = 0}^{n} t_y \left(k + 1 \right)
	+ c_5 \sum \limits_{y = 0}^{n} \sum \limits_{x = 0}^{k} t_y t_x\\
	+ c_6 \sum \limits_{y = 0}^{n} \sum \limits_{x = 0}^{k} t_y t_x
	+ c_7 \sum \limits_{y = 0}^{n} \sum \limits_{x = 0}^{k} t_y t_x
	+ c_9 \sum \limits_{y = 0}^{n} t_y
	\label{eq:linedetection-analyze2}
\end{multline}
\begin{multline}
	T(I) =
	c_1
	+ c_2
	+ c_3 \left(n + 1\right)
	+ c_4 \left[n \left(k + 1 \right)\right]
	+ c_5 n k
	+ c_6 n k
	+ c_7 n k
	+ c_9 n\\
	= c_1 + c_2 + c_3 + \left(c_3 + c_4 + c_9\right) n + \left(c_4 + c_5 + c_6 + c_7\right) n k
	\label{eq:linedetection-analyze3}
\end{multline}
\end{subequations}

Das Verfahren zur Bestimmung der Edgels (\autoref{alg:findedgels-horizontal}) benötigt das monochrome Bildsignal $I_m$,
 sowie die Position der oberen linken Ecke der Region, die durch oben $t$ und links $l$ definiert ist. Die Breite und
 Höhe der Region ist durch $\mathit{rw}$ und $\mathit{rh}$ angegeben. Die Abmessung des Bildsignals werden als $w$ und
 $h$ bezeichnet. Der Pointer $E$ wird zur Speicherung der gefundenen \gls{edgels} verwendet.

\input{alg/findedgels}

Zeile~\ref{alg:findedgels-horizontal-scanlinestart}--\ref{alg:findedgels-horizontal-scanlineend} ist für den Aufbau der
 horizontalen Scanlines verantwortlich. Die Überprüfung sorgt dafür, dass die Scanlines bis zum Ende der Region im
 Abstand von $5$ Pixeln untersucht werden. Nach der Initialisierung der Variablen wird in der Schleife von
 Zeile~\ref{alg:findedgels-horizontal-loopstart}--\ref{alg:findedgels-horizontal-loopend} jeder Pixel auf der Scanline
 untersucht. Zuerst wird in Zeile~\ref{alg:findedgels-horizontal-convolute} die Faltung mit einem Gauß-Kernel
 vorgenommen (Vgl. \autoref{alg:derivativeofgauss-horizontal}, S.~\pageref{alg:derivativeofgauss-horizontal}). Der Test
 in Zeile~\ref{alg:findedgels-horizontal-foundedgel} überprüft anschließend das Ergebnis der Faltung. Wenn der
 Schwellwert nicht überschritten wird, gibt es keinen genügend großen Anstieg des Gradienten und das Ergbnis wird auf
 $0$ gesetzt. Wird der Schwellwert überschritten, handelt es sich um einen Edgel und das Ergbnis wird in den
 Bedingungen von Zeile~\ref{alg:findedgels-horizontal-maxima} weiter untersucht, ob es sich um ein lokales Maximum
 handelt. Ein lokales Maximum bedeutet, dass ein Edgel einen größeren Gradienten besitzt als seine beiden Nachbarn.

Die Bedingung in Zeile~\ref{alg:findedgels-horizontal-maxima} wird bei der ersten Überprüfung immer fehlschlagen.
 Dadurch wird sichergestellt, dass kein Maxium an den Rändern existiert, da hier nicht genügend Nachbarn vorhanden sind
 um eine verlässliche Aussage zu treffen. Zeile~\ref{alg:findedgels-horizontal-copy-prev1} und
 Zeile~\ref{alg:findedgels-horizontal-copy-edgel} kopieren die Werte für den nächsten Durchlauf. Durch das kopieren der
 Werte werden die Nachbarn für den nächsten Durchlauf um eine Position weiterverschoben. Nur bei einem lokalen Maximum
 wird die Position des Edgels gespeichert, und seine Orientierung (Vlg. \autoref{alg:sobel},
 S.~\pageref{alg:sobel}) berechnet. Der Edgel wird in (einer Liste|einem Memorypool) zu weiteren Verarbeitung
 gespeichert.

Sind alle Pixel auf einer Scanline untersucht, wird in Zeile~\ref{alg:findedgels-horizontal-increment} die nächste
 Scanline ausgewählt. Das Verfahren wird solange wiederholt, bis alle Scanlines innerhalb der Region untersucht wurden.

\autoref{alg:findedgels-vertical} untersucht die vertikalen Scanlines in Zeile
 \ref{alg:findedgels-vertical-scanlinestart}--\ref{alg:findedgels-vertical-scanlineend} analog zu
 \autoref{alg:findedgels-horizontal} Zeile
 \ref{alg:findedgels-horizontal-scanlinestart}--\ref{alg:findedgels-horizontal-scanlineend}.

\autoref{alg:derivativeofgauss-horizontal} und \autoref{alg:derivativeofgauss-vertical} berechnen den Gradienten durch Faltung mit dem Gauß-Kernel
$\left( \begin{smallmatrix}
-3& -5& 0& 5& 3
\end{smallmatrix} \right)$
 auf der horizontalen und vertikalen Scanline. Als Parameter benötigt der Algorithmus den Pointer des monochromen
 Bildsignals $I_m$, die Position des Pixels ($x$ und $y$), sowie die Breite $w$ und Höhe $h$ von $I_m$. In Zeile
 \ref{alg:derivativeofgauss-horizontal-readstart}--\ref{alg:derivativeofgauss-horizontal-readend} werden durch die
 Funktion \textproc{getpixel} (Vgl. \autoref{alg:getpixel}, S. \pageref{alg:getpixel}) die benötigten Pixelwerte
 ausgelsen und den Variablen zugewiesen. Im Anschluss werden die Werte mit dem Gauß-Kernel
$\left( \begin{smallmatrix}
-3& -5& 0& 5& 3
\end{smallmatrix} \right)$
berechnet um den Gradienten zu bestimmen.

\input{alg/derivativeofgauss.tex}

Durch die Multiplikation mit $\tfrac{1}{16}$ wird sichergestellt, dass der maximale Wert

\begin{equation}
	\frac{1}{16}
	\cdot
	\begin{pmatrix}
		-3& -5& 0& 5& 3
	\end{pmatrix}
	\cdot
	\begin{pmatrix}
		0& 0& 0& 255& 255
	\end{pmatrix}
	= 127.5
\end{equation}

und der minimale Wert

\begin{equation}
	\frac{1}{16}
	\cdot
	\begin{pmatrix}
		-3& -5& 0& 5& 3
	\end{pmatrix}
	\cdot
	\begin{pmatrix}
		255& 255& 0& 0& 0
	\end{pmatrix}
	= -127.5
\end{equation}

für ein monochromes Bild eingehalten werden.

Bei genauer Betrachtung von \autoref{alg:derivativeofgauss-horizontal} und \autoref{alg:derivativeofgauss-vertical}
 fällt auf, dass der Wert $p_3$ in der Berechnung nicht mit einfliesst. Dies ist darauf zurückzuführen, dass bei der
 Multiplikation des Gauß-Kernels an der dritten Stelle des Filter mit $0$ definiert ist. Eine Multiplikation mit $0$
 ergibt immer $0$ und kann somit vernachlässigt werden. Die Laufzeit von \autoref{alg:derivativeofgauss-horizontal} und
 \autoref{alg:derivativeofgauss-vertical} ist konstant.

In \autoref{alg:sobel} wird, wie in \autoref{alg:derivativeofgauss-horizontal}, mittels Faltung die Orientierung eines \gls{edgels} bestimmt. Als Eingabeparameter wird das monochrome Bildsignal $I_m$, dessen Breite $w$ und Höhe $h$, sowie die Position des \gls{edgels} ($x,y$) benötigt.

\input{alg/sobel}

In Zeile \ref{alg:sobel-readstart}--\ref{alg:sobel-readend} werden die Pixelwerte ausgelsen und den Variablen zugewiesen. In Zeile \ref{alg:sobel-convolutestart}--\ref{alg:sobel-convoluteend} erfolgt die Faltung mit dem Sobel-Operator\footcite[Vgl.][S.~120--123]{burger05}, dessen Filter

\begin{subequations}
\begin{align}
	H_x =&
	\begin{pmatrix}
		1& 0& -1&\\
		2& 0& -2&\\
		1& 0& -1
	\end{pmatrix}
\end{align}
\begin{align}
	H_y =&
	\begin{pmatrix}
		1& 2& 1&\\
		0& 0& 0&\\
		-1& -2& -1
	\end{pmatrix}
\end{align}
\end{subequations}

den Gradienten $G_x$ und $G_y$ bestimmen. Wie in \autoref{alg:derivativeofgauss-horizontal} werden Multiplikationen von $0$-Werten des Filters vernachlässigt. Mit

\begin{equation}
	\label{eq:orientation}
	\Phi(x,y) = \arctan{\left(\tfrac{G_y}{G_x}\right)}
\end{equation}

wird die Orientierung in Zeile \autoref{alg:sobel-arctan} berechnet. Die Orientierung unterscheidet sich um $180^\circ$
 wenn anstatt von weiß nach schwarz ein verlauf von schwarz nach weiß erfolgt. Das Ergebnis liegt im Bereich
 $-\pi < v \leq \pi$. $\arctan$ in \autoref{eq:orientation} kann in C durch \textproc{atan2} zur Berechnung verwendet
 werden. Die Laufzeit von \autoref{alg:sobel} ist konstant.

Die Datenstruktur eines \gls{edgels} besteht aus der $x$- und $y$-Koordinate und der Orientierung
 (Vgl. \autoref{alg:datastructure-edgel}). Lese- und Schreibzugriffe auf die Elemente eines \gls{edgels} sind konstant.

\input{alg/datastructure-edgel}

Der Vergleich, ob \gls{edgels} kompatibel sind, wird mit \autoref{alg:compatibleedgel} bewerkstelligt. Als Parameter
 werden zwei zu vergleichende \gls{edgels} $e_1$ und $e_2$ übergeben. In Zeile~$6$ und $13$ wird sichergestellt, dass
 $e_1.o$ und $e_2.o$ innerhalb von $67.5^\circ$\footcite[Vgl.][S.~417]{clarke96} liegen und damit kompatibel wären.
 Dies wird durch

\begin{equation}
	d = 2 \pi \left( \frac{ \frac{67.5}{2} }{360} \right) = 0.589
\end{equation}

überprüft. Es muss sichergestellt werden, dass die Orientierung in Bogenmaß erfolgt.


Die Datenstruktur eines Liniensegments ist in \autoref{alg:datastructure-line} definiert. Eine Linie besteht aus den
 \gls{edgels} $s$ und $e$, die den Start- und End-Punkt der Linie darstellen. Variable $c$ speichert die Anzahl der
 unterstützenden Edgels der Linie. Die Lese- und Schreibzugriffe auf die Datenstruktur ist konstant.

\input{alg/datastructure-edgelpool}

\input{alg/edgelpool-getmemorypools}

\input{alg/edgelpool-getmemorypool}

\input{alg/edgelpool-resetmemorypool}

\input{alg/edgelpool-freememorypool}

\input{alg/edgelpool-count}

\input{alg/edgelpool-addedgel}

\input{alg/edgelpool-getedgel}

\input{alg/edgelpool-removeedgel}

\input{alg/datastructure-line}

\input{alg/compatibleedgel}

\input{alg/findlinesegments}

% subsection hirzer (end)

% section analyse (end)