\section{Digitale Bildverarbeitung} % (fold)
\label{sec:bildverarbeitung}
\begin{comment}
	Bildverarbeitung: Notwendige Verfahren und Konzepte erläutern.
\end{comment}

\begin{comment}
	YUV und RGB bzw. RGBA
	kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange, kCVPixelFormatType_420YpCbCr8BiPlanarFullRange and kCVPixelFormatType_32BGRA, except on iPhone 3G, where the supported pixel formats are kCVPixelFormatType_422YpCbCr8 and kCVPixelFormatType_32BGRA..(AVCaptureVideoDataOutput Class Reference)

	\subsection{Grundlagen} % (fold)
	\label{sec:grundlagen}
	Ein digitales Bild ist definiert durch seine Bildgröße und der Auflösung. Die Bildgröße ist in Höhe und Breite angegeben und eine entsprechende Bildmatrix kann durch die Bildspalten $u$ und Bildzeilen $v$ angegeben werden. Die Auflösung eines Bildes bezeichnet die räumliche Ausdehnung in \gls{dpi}, die in den meisten Bildverarbeitungsschritten vernachlässigt werden kann.

Um auf ein \gls{pixel} aus der Bildmatrix zugreifen zu können, benötigen wir ein Koordinatensystem. Bei digitalen
 Bildern unterscheidet sich das verwendete Koordinatensystem von einem kartesischen Koordinatensystem dadurch, dass der
 Ursprungspunkt bei Bildern links oben liegt. Die \(x\)-Achse verläuft von links nach rechts und die \(y\)-Achse von
 oben nach unten. TODO: vgl Abbildung.

	Die Information eines \gls{pixel} ist als binärer Wert mit der Länge \(k\) gespeichert. Der Wertebereich eines \gls{pixel} umfasst \(\left[0 \dotsc 2^k\right]\), wobei der genaue Wertebereich abhängig vom eingesetzten Typ ist.

	Man unterscheidet im Allgemeinen zwischen Farb-, Monochrome- und Binärbildern, die eine direkte Auswirkung auf den Wertebereich haben. Bei Farbbildern wird häufig eine Komponente für Rot, Grün und Blau verwendet und ist typischerweise in 8 Bits kodiert. Ein Pixel besteht somit aus \(3 \cdot 8 = 24\) Bits mit einem Wertebereich von \(\left[0 \dotsc 255\right]\) pro Farbkomponente.\\TODO: Bild mit Speicherbeschreibung für RGB

	Monochromebilder bestehen nur aus einem Intensitätskanal der ebenfalls mit 8 Bits kodiert wird. Der Wertebereich eines Pixel entspricht \(\left[0 \dotsc 255\right]\).\\TODO: Bild mit Speicherbeschreibung für Monochrome

	Bei Binärbildern werden Informationen nur in einem Bit gespeichert und der Wert entspricht somit \(0\) oder \(1\) für Schwarz oder Weiß.\\TODO: Bild mit Speicherbeschreibung für Binär.
	% section grundlagen (end)
\end{comment}

Bevor ich mich den \gls{AR}-Verfahren widme, möchte ich die grundlegenden Aspekte der Digitalen Bildverarbeitung benennen, die in den nachfolgenden Kapiteln benötigt werden. Dabei werde ich keinen kompletten Überblick über Digitale Bildverarbeitung vermitteln, sondern nur Bereiche besprechen die für die Untersuchung der \gls{AR} berücksichtigt werden müssen.


\subsection{Grundlagen} % (fold)
\label{sub:grundlagen}

Ein digitales Bild ist eine Ansammlung numerischer Werte, die in einem Array gespeichert sind. Durch die Höhe und Breite des Bildes kann das Array, wie in \autoref{fig:bildmatrix}, als Matrix dargestellt werden. Die Höhe $N$ entspricht dann den Zeilen und die Breite $M$ den Spalten der Matrix. Ein Bild $I$ ist somit definiert als eine Funktion auf einer Menge von Bildwerten $\mathbb{P}$, wie in \autoref{eq:digitalesBild} dargestellt ist.

\begin{figure}
	\centering
	\def\svgwidth{.5\columnwidth}
	\input{resources/Bildmatrix.pdf_tex}
	\caption{Bildmatrix}
	\label{fig:bildmatrix}
\end{figure}

\begin{equation}
	I\left(u,v\right)\in\mathbb{P} \text{ und } u,v\in\mathbb{N}
	\label{eq:digitalesBild}
\end{equation}

Um auf ein \gls{pixel} aus der Bildmatrix zugreifen zu können, bedienen wir uns eines Koordinatensystems. Im Unterschied zu einem kartesischen Koordinatensystem ist bei Bildern der Ursprungspunkt links oben. Die \(x\)-Achse verläuft von links nach rechts und die \(y\)-Achse von oben nach unten. \begin{comment}\\TODO:vgl abbildung\end{comment} Welche Werte in einem \gls{pixel} gespeichert sind und wie diese Werte zu interpretieren sind, ist abhängig vom verwendeten Bildtyp.

% section grundlagen (end)

\subsection{Bildtypen} % (fold)
\label{sub:bildtypen}

Der Wert eines \gls{pixel} ist als binärer Wert der Länge $k$ angegeben. Darüber hinaus bestimmt der verwendete Bildtyp über die weiteren Informationen eines \gls{pixel}.

Monochrome Bilder, die im allgemeinen Sprachgebrauch als Schwarz/Weiß Bilder bezeichnet werden, besitzen nur eine Komponente, die als Luminanz oder auch Intensität bezeichnet wird. Die Information des \gls{pixel} wird im Allgemeinen mit 8 Bit kodiert, sodass sich ein Wertebereich von $2^8 = \left[0\dotsc255\right]$ ergibt.

Binäre Bilder sind eine spezielle Form der monochromen Bilder. In binären Bildern werden nur Schwarz/Weiß Werte gespeichert. Die Information kann dadurch in nur einem Bit, mit $0$ für Schwarz und $1$ für Weiß, gespeichert werden.

Farbbilder speichern im Unterschied zu monochromen Bildern mehr Informationen in einem \gls{pixel} ab. Der Aufbau der
Informationen von Farbbildern ist abhängig von dem eingesetzten Farbraum, der in \autoref{sub:farbräume} erläutert
wird. In den meisten Fällen wird die Information eines Farbbildes in drei Komponenten für Rot, Grün und Blau, mit
jeweils 8 Bit, kodiert. Somit besteht ein Pixel aus \(3 \cdot 8 = 24\) Bits mit einem Wertebereich von
\(\left[0 \dotsc 255\right]\) pro Farbkomponente.

Der Aufbau der Farbinformationen ist abhängig von der Anordnung, die in \autoref{sub:pixelanordnung} genauer definiert wird.

% subsection bildtypen (end)

\subsection{Farbräume} % (fold)
\label{sub:farbräume}

Bei Digitaler Bildverarbeitung wird häufig der RGB Farbraum eingesetzt, der aus roten, grünen und blauen Komponenten besteht (\autoref{fig:rgbLenna}).

\begin{figure}[!ht]
	\centering
	\includegraphics[width=.2\textwidth]{resources/Lenna.pdf}
	\includegraphics[width=.2\textwidth]{resources/Lenna_R.pdf}
	\includegraphics[width=.2\textwidth]{resources/Lenna_G.pdf}
	\includegraphics[width=.2\textwidth]{resources/Lenna_B.pdf}
	\caption{RGB Farbraum Beispiel}
	\label{fig:rgbLenna}
\end{figure}

Bei RGB handelt es sich um ein additives Farbsystem, dass durch Mischung der Primärfarben einen Farbton und dessen
 Helligkeit generiert. Der RGB Farbraum kann als dreidimensionaler Würfel dargestellt werden
 (\autoref{fig:rgbWuerfel}). Seine Koordinatenachsen stellen den Wertebereich für die Grundfarben Rot, Grün und Blau
 dar. Normiert man den Würfel zu einem Einheitswürfel der Länge $1$, umfasst jede Achse einen Bereich von
 \(\left[0 \dotsc 1.0\right]\). Innerhalb dieses Würfels kann durch Verschiebung der Koordinate jeder Farbton generiert
 werden. Die Grundfarben können in diesem Würfel durch die Punkte $R = \left(1,0,0\right)$, $G = \left(0,1,0\right)$
 und $B = \left(0,0,1\right)$ dargestellt werden. Schwarz ($S = \left(0,0,0\right)$) und Weiß
 ($W = \left(1,1,1\right)$) werden auf die gleiche Weise dargestellt.

\begin{figure}[!ht]
	\centering
	\def\svgwidth{.2\columnwidth}
	\input{resources/RGBWuerfel.pdf_tex}
	\caption{RGB Farbwürfel}
	\label{fig:rgbWuerfel}
\end{figure}

\begin{table}[!ht]
	\begin{center}
	\begin{tabular}[]{r|c|c|c}
	Farbe & R & G & B \\ \hline\hline
	rot & 1.0 & 0.0 & 0.0 \\
	grün & 0.0 & 1.0 & 0.0 \\
	blau & 0.0 & 0.0 & 1.0 \\
	schwarz & 0.0 & 0.0 & 0.0 \\
	weiß & 1.0 & 1.0 & 1.0 \\
	grau & 0.5 & 0.5 & 0.5 \\
	\end{tabular}
	\caption{RGB Werte}
 	\label{tbl:rgbwerte}
	\end{center}
\end{table}

YUV und YCbCr sind standardisierte Formate zur Aufnahme, Darstellung und Übertragung von Bildern im Fehrnsehbereich und
stellen andere Farbräume dar. YUV findet Verwendung bei analogen PAL und NTSC Systemen während YCbCr bei digitalen
Systemen verwendet wird. Beide Farbräume unterteilen die Informationen in eine Luminanzkomponente $Y$ und zwei
Komponenten zur Darstellung unterschiedlicher \gls{chrominanz} (\autoref{fig:yuvLenna}).

\begin{figure}[!ht]
	\centering
	\includegraphics[width=.2\textwidth]{resources/Lenna.pdf}
	\includegraphics[width=.2\textwidth]{resources/Lenna_Y.pdf}
	\includegraphics[width=.2\textwidth]{resources/Lenna_U.pdf}
	\includegraphics[width=.2\textwidth]{resources/Lenna_V.pdf}
	\caption{YUV Farbraum Beispiel}
	\label{fig:yuvLenna}
\end{figure}

Bei YUV ist die Chromakomponente $U$ als Differenz zwischen der Luminanz $Y$ und dem Blauanteil definiert (Vgl.~\autoref{eq:uchroma}).

\begin{equation}
	U = 0.492 \cdot \left(B-Y\right)
	\label{eq:uchroma}
\end{equation}

Die Chromakomponente $V$ definiert die Differenz von Luminanz $Y$ und dem Rotanteil (Vgl.~\autoref{eq:vchroma}).

\begin{equation}
	V = 0.877 \cdot \left(R-Y\right)
	\label{eq:vchroma}
\end{equation}

Die Chromakomponenten $Cb$ und $Cr$ von YCbCr sind, wie bei YUV, Differenzwerte des Blau- und Rotanteil und der Luminanz. Der Unterschied zwischen YUV und YCbCr besteht in der unterschiedlichen Berechnung der \gls{chrominanz} und ist in \citeauthor{burger05}\footcite[][S.265--266]{burger05} beschrieben.

Durch die Trennung der Luminanz und \gls{chrominanz} ist es möglich das Signal auf Schwarz/Weiß Fernsehern zu nutzen, indem nur die Luminanzkomponente berücksichtigt wird. Bei Farbfernsehern werden die zusätzlichen Chromakomponenten verwendet.

% subsection farbräume (end)

\subsection{Pixel Anordnung} % (fold)
\label{sub:pixelanordnung}
Bei \gls{pixel} gibt es unterschiedliche Modelle der Anordnung von Farbkomponenten. Man unterscheidet die Komponentenanordnung, auch planare Anordnung genannt, von der gepackten Anordnung. Der Zugriff auf die Farbinformationen ist dabei abhängig vom eingesetzten Farbraum. Im weiteren Verlauf wird die gepackte Anordnung für den RGB Farbraum erläutert. Für YCbCr sind die vorgestellten Modelle anzupassen.

Bei der planaren Anordnung werden die Farbkomponenten in jeweils eigenen Arrays mit gleicher Größe gespeichert. Ein Bild

\begin{equation}
	I = \left(I_R, I_G, I_B\right)
	\label{eq:planarImage}
\end{equation}

besteht aus den den drei Luminanzbildern $I_R$, $I_G$ und $I_B$ (\autoref{fig:planareAnordnung}). Der Zugriff auf ein \gls{pixel} erfolgt über das Auslesen aller drei Arrays, wie in \citeauthor{burger05}\footcite[Vgl.][S.~235--236]{burger05} beschrieben. Der Zugriff erfolgt durch

\begin{equation}
	\begin{pmatrix}
		R\\
		G\\
		B
	\end{pmatrix}
	\leftarrow
	\begin{pmatrix}
		I_R\left(u,v\right)\\
		I_G\left(u,v\right)\\
		i_B\left(u,v\right)
	\end{pmatrix}.
	\label{eq:readPlanarImage}
\end{equation}

\begin{figure}[!ht]
	\centering
	\def\svgwidth{.5\columnwidth}
	\input{resources/planareAnordnung.pdf_tex}
	\caption{Planare Anordnung}
	\label{fig:planareAnordnung}
\end{figure}

Bei der gepackten Anordnung sind alle Farbkomponenten in einem \gls{pixel} gespeichert und in einem Array hinterlegt (\autoref{fig:gepackteAnordnung}). Die gepackte Anordnung ist mit

\begin{equation}
	I\left(u,v\right) = \left(R,G,B\right)
	\label{eq:packedImage}
\end{equation}

definiert.

\begin{figure}[!ht]
	\centering
	\def\svgwidth{.5\columnwidth}
	\input{resources/gepackteAnordnung.pdf_tex}
	\caption{Gepackte Anordnung}
	\label{fig:gepackteAnordnung}
\end{figure}

Im allgemeinen wird ein Element an Stelle $(u,v)$ eines Bildes $I$ durch \eqref{eq:readPackedRGB} zugegriffen.

\begin{equation}
	\begin{pmatrix}
		R\\
		G\\
		B
	\end{pmatrix}
	\leftarrow
	\begin{pmatrix}
		Red\bigl(I\left(u,v\right)\bigr)\\
		Green\bigl(I\left(u,v\right)\bigr)\\
		Blue\bigl(I\left(u,v\right)\bigr)
	\end{pmatrix}
	\label{eq:readPackedRGB}
\end{equation}

$Red()$, $Green()$ und $Blue()$ sind abhängig vom eingesetzten Format\footcite[Vgl.][S.~236--237]{burger05}.
% subsection pixelanordnung (end)

\subsection{Filter und Faltung} % (fold)
\label{sub:filter}
Ein Filter ist eine Operation, mit dessen Hilfe ein Eingangsbild $I$ durch eine mathematische Abbildung in ein
 Ausgangsbild $I'$ überführt wird. Im Gegensatz zu Punktoperationen, operieren Filter auf Regionen um zum Beispiel
 Bilder zu glätten oder zu schärfen.

Aus einer Region $R_{u,v}$ eines Eingangsbild $I$ wird der neue Pixelwert $I'(u,v)$ berechnet. Die Größe der
 Filterregion bestimmt die Anzahl der Pixel aus $I$, die zur Berechnung des neuen Pixelwerts $I'(u,v)$ verwendet
 werden. Üblicherweise werden $3 \times 3$ oder $5 \times 5$ Filter verwendet, aber auch größere Filter mit $21 \times
 21$ Pixeln sind möglich. Anhand der Schreibweise der Filter erkennt man, das es sich bei den Filtern um Matrizen
 handelt.

Bei einer Filtermatrix wird ein eigenes Koordinatensystem verwendet, dessen Ursprung in der Mitte der Matrix liegt.
 Aufgrund dieses Koordinatensystem sind die Koordinaten sowohl positiv als auch negativ. Bei einer $3 \times 3$
 Filtermatrix $H$ sähen die absoluten Koordinaten an der Stelle $(i,j)$ wie folgt aus:

\begin{equation}
	H(i,j) =
	\begin{pmatrix}
		\left(i-1, j-1\right)&	\left(i, j-1\right)&	\left(i+1, j-1\right)\\
		\left(i-1, j\right)& 	\left(i, j\right)&		\left(i+1, j\right)\\
		\left(i-1, j+1\right)&	\left(i, j+1\right)&	\left(i+1, j+1\right)
	\end{pmatrix}
\end{equation}

Somit können alle Pixel von $I'$ durch

\begin{equation}
	I'\left(u,v\right) \gets
	\sum \limits_{\left(i = -1\right)}^{i = 1}
	\sum \limits_{\left(j = -1\right)}^{j = 1}
	I\left(u + i, v + j\right) \cdot H\left(i,j\right)
\end{equation}

berechnet werden. Für Filter mit einer anderen Größe als $3 \times 3$, lautet die Formel

\begin{equation}
	I'\left(u,v\right) \gets
	\sum_{\left(i,j\right)\in\mathbb{R}} I\left(u + i, v + j\right) \cdot H\left(i,j\right)
\end{equation}

wobei $\mathbb{R}$ die Größe des Filters angibt\footcite[Vgl.][S.~92--93]{burger05}.

Filter können an den Rändern nicht mathematisch korrekt berechnet werden\footcite[Vgl.][S.~113]{burger05}, da der Filter $H$ an den Bildrändern über die definierte Bildmenge hinausragt. Um dieses Problem zu umgehen, gibt es die Möglichkeit

\begin{enumerate}
	\item am Randbereich einen konstanten Wert zuzuweisen,\label{konstant}
	\item den ursprünglichen Bildwert beizubehalten,\label{nix}
	\item die Randwerte zu berechnen, indem
	\begin{enumerate}
		\item außerhalb des Bildbereichs konstante Werte angenommen werden,\label{berechneKonstant}
		\item die Randpixel fortgesetzt werden,\label{berechneRand}
		\item die Bildwerte wiederholt werden.\label{berechneBild}
	\end{enumerate}
\end{enumerate}

Bei \autoref{konstant} wird der sichtbare Bildbereich verkleinert und bei \autoref{nix} der Filter an den Rändern nicht
 angewendet. Bei \autoref{berechneKonstant} kann durch die Zuweisung eines konstanten Wertes, beispielsweise Schwarz,
 das Ergebnis verfälschen. \autoref{berechneRand} weist die geringste Verfälschung auf. Bei \autoref{berechneBild} wird
 durch die Wiederholung des Bildes implizit eine periodische Funktion betrachtet. Welche dieser Randbetrachtung
 eingesetzt wird ist abhängig von den benötigten Ergebnissen und Filtern und muss für jede Anwendung gesondert
 betrachtet werden.

In der digitalen Bildverarbeitung basieren Filter auf der mathematischen Operation der Faltung
\footcite[Vgl.][S.~101--104]{burger05}, bei der für zwei Funktionen ein dritte Funktion erzeugt wird. Die diskrete
 lineare Faltung ist definiert als

\begin{equation}
	I'\left(u,v\right) =
	\sum \limits_{i = -\infty}^{\infty}
	\sum \limits_{j = -\infty}^{\infty}
	I\left(u - i, v - j\right) \cdot H\left(i,j\right)
\end{equation}

und gekürzt

\begin{equation}
	I' = I * H,
\end{equation}

wobei $I$ dem Bildsignal und $H$ dem Faltungskern entspricht. Die Operation der Faltung ist die Grundlage aller
 linearen Filter in der digitalen Bildverarbeitung. Unterschiedliche Filter sind nur durch den Filterkern (Kernel)
 definiert. Die Faltungsoperation besitzt die algebraischen Eigenschaften der Kommutativität, Assoziativität und
 Distributivität.

\begin{align}
	&\text{Kommutativität: } &I * H = H * I\\
	&\text{Assoziativität: } &A * (B * C) = (A * B) * C\\
	&\text{Distributivität: } &H * \left(I_1 + I_2\right) = \left(H * I_1\right) + \left(H * I_2\right)
\end{align}

Durch die Assoziativität kann ein Kernel $H$ als Produkt mehrerer kleiner Kernel ausgedrückt werden was wiederum
 Rechenoperationen einspart. Ein $3 \times 3$ Filter kann in eine $x$-Richtung und $y$-Richtung aufgeteilt werden.

\begin{align}
	H_{xy} = & H_x * H_y\\
	\begin{pmatrix}
		1& 1& 1\\
		1& 1& 1\\
		1& 1& 1
	\end{pmatrix} = &
	\begin{pmatrix}
		1& 1& 1
	\end{pmatrix}
	*
	\begin{pmatrix}
		1\\
		1\\
		1
	\end{pmatrix}
\end{align}

Bei der Berechnung von $I * H_{xy}$ entspricht dies $3 \cdot 3 = 9$ Multiplikationen und bei der Berechnung von
 $I * H_x * H_y = 3 + 3 = 6$ Multiplikationen.

% subsection filter (end)

% section bildverarbeitung (end)
